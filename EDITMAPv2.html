<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSO Map Viewer</title>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2a2a2a;
            --primary-color: #4CAF50;
            --primary-hover: #5cb85c;
            --text-color: #f0f0f0;
            --text-muted: #888;
            --border-color: #444;
            --font-family: 'Inter', sans-serif;
        }
        html { font-family: var(--font-family); }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            font-family: var(--font-family);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        .sidebar {
            width: 350px;
            min-width: 300px;
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-y: auto;
            box-sizing: border-box;
        }
        header h1 {
            margin: 0 0 0.5rem 0;
            font-size: 1.75rem;
            color: var(--primary-color);
        }
        p.description {
            color: var(--text-muted);
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
        }
        h2 {
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin: 0 0 1rem 0;
        }
        .control-group {
            background-color: #222;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        .file-input-group {
            margin-bottom: 1rem;
        }
        .file-input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        input[type="file"], input[type="number"], select, input[type="text"] {
            width: 100%;
            background-color: #3e3e3e;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9rem;
        }
        input[type="file"]::file-selector-button {
            background-color: #555;
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 1rem;
        }
        input[type="file"]::file-selector-button:hover { background-color: #666; }

        .action-button {
            width: 100%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.2rem;
            border-radius: 4px;
            font-family: var(--font-family);
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            font-size: 1rem;
        }
        .action-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .action-button:disabled { background-color: #555; opacity: 0.6; cursor: not-allowed; }
        .log-entries {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--bg-color);
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column-reverse;
            min-height: 150px;
        }
        .log-entry { margin-bottom: 0.25rem; line-height: 1.4; color: #ccc; word-break: break-word; }
        .log-timestamp { color: var(--text-muted); margin-right: 0.5rem; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #map-canvas {
            display: block;
            background-color: var(--bg-color);
            cursor: grab;
        }
        #map-canvas.grabbing {
            cursor: grabbing;
        }
        #welcome-message {
            color: var(--text-muted);
            text-align: center;
            font-size: 1.2rem;
        }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .inline { display: flex; gap: 0.5rem; align-items: center; }
        .small-muted { color: var(--text-muted); font-size: 0.8rem; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <header>
                <h1>HSO Map Viewer</h1>
                <p class="description">Tải file map và tileset tương ứng để xem bản đồ một cách trực quan.</p>
            </header>
    
            <div class="control-group">
                <h2>1. Tải File</h2>
                <div class="file-input-group">
                    <label id="map-label" for="map-input">File Bản Đồ (.map)</label>
                    <input type="file" id="map-input" accept=".map,.*">
                </div>
                 <div class="file-input-group">
                    <label id="tileset-label" for="tileset-input">Ảnh Tileset (.png)</label>
                    <input type="file" id="tileset-input" accept=".png">
                </div>
                 <div class="file-input-group">
                    <label for="icon-input">Ảnh Icons (.png)</label>
                    <input type="file" id="icon-input" accept=".png" multiple>
                </div>
            </div>

            <div class="control-group">
                <h2>2. Lưu Bản Đồ</h2>
                <button id="save-map-button" class="action-button" disabled>Lưu Dữ Liệu (CMD 12)</button>
            </div>

            <div class="control-group">
                <h2>3. Chỉnh Kích Thước</h2>
                <div class="grid-2">
                    <div>
                        <label for="new-width-input">Chiều rộng mới (tiles)</label>
                        <input id="new-width-input" type="number" min="1" step="1" placeholder="width">
                    </div>
                    <div>
                        <label for="new-height-input">Chiều cao mới (tiles)</label>
                        <input id="new-height-input" type="number" min="1" step="1" placeholder="height">
                    </div>
                </div>
                <div class="file-input-group">
                    <label for="anchor-select">Neo giữ (anchor)</label>
                    <select id="anchor-select">
                        <option value="top-left" selected>Giữ góc trái trên</option>
                        <option value="center">Giữ giữa</option>
                        <option value="bottom-right">Giữ góc phải dưới</option>
                    </select>
                </div>
                <div class="grid-2">
                    <div>
                        <label for="fill-tile-input">Tile mặc định khi mở rộng</label>
                        <input id="fill-tile-input" type="number" min="0" max="255" step="1" value="0">
                    </div>
                    <div class="inline" style="margin-top: 1.8rem;">
                        <input id="clip-objects-checkbox" type="checkbox" checked>
                        <label for="clip-objects-checkbox">Xóa đối tượng nằm ngoài</label>
                    </div>
                </div>
                <div class="small-muted" style="margin-top: 0.5rem;">
                    Lưu ý: Tile size = 24px. Tile = 0 sẽ để trống theo client.
                </div>
                <button id="apply-resize-button" class="action-button" style="margin-top: 0.75rem;">Áp dụng thay đổi</button>
            </div>

            <div class="control-group">
                <h2>4. Va chạm</h2>
                <div class="inline" style="margin-bottom: 0.5rem;">
                    <input type="checkbox" id="show-collision" checked>
                    <label for="show-collision">Hiển thị lớp va chạm 0/1/2</label>
                </div>
                <div class="file-input-group">
                    <label for="collision-mode">Chế độ hiển thị</label>
                    <select id="collision-mode">
                        <option value="number" selected>Hiển thị số</option>
                        <option value="color">Tô màu</option>
                    </select>
                </div>
                <div class="grid-2">
                    <div>
                        <label for="f-threshold">Ngưỡng F (chặn)</label>
                        <input id="f-threshold" type="number" min="0" max="255" step="1" value="32">
                    </div>
                    <div>
                        <label for="g-threshold">Ngưỡng G (nước)</label>
                        <input id="g-threshold" type="number" min="0" max="255" step="1" value="26">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2>5. Chỉnh sửa Tile</h2>
                <div class="inline" style="margin-bottom: 0.5rem;">
                    <input type="checkbox" id="tile-edit-mode">
                    <label for="tile-edit-mode">Bật chế độ sửa tile (vẽ)</label>
                </div>
                <div class="small-muted">Tile đang chọn: <strong id="selected-tile-id">1</strong></div>
                <div id="tile-palette-panel" style="display:none; margin-top: 0.5rem;">
                    <div id="tile-palette-container" style="display:grid; grid-template-columns: repeat(auto-fill, 24px); gap:4px;"></div>
                </div>
            </div>

            <div class="control-group">
                <h2>6. Sửa Va chạm</h2>
                <div class="inline" style="margin-bottom: 0.5rem;">
                    <input type="checkbox" id="collision-edit-mode">
                    <label for="collision-edit-mode">Bật chế độ sửa va chạm (nhấp để đổi)</label>
                </div>
                <div class="file-input-group">
                    <label for="collision-edit-action">Hành động</label>
                    <select id="collision-edit-action">
                        <option value="cycle" selected>Nhấp để chuyển 0 → 1 → 2 → 0</option>
                        <option value="set-0">Đặt 0 (đi được)</option>
                        <option value="set-1">Đặt 1 (chặn)</option>
                        <option value="set-2">Đặt 2 (nước)</option>
                    </select>
                </div>
                <div class="grid-2">
                    <div>
                        <label for="collision-blocked-id">ID tile cho 1 (chặn)</label>
                        <input id="collision-blocked-id" type="number" min="0" max="255" step="1" value="32">
                    </div>
                    <div>
                        <label for="collision-water-id">ID tile cho 2 (nước)</label>
                        <input id="collision-water-id" type="number" min="0" max="255" step="1" value="26">
                    </div>
                </div>
                <button id="bake-collision-button" class="action-button">Ghi va chạm vào tile (bake)</button>
                <div class="small-muted" style="margin-top: 0.5rem;">Mẹo: Chọn ID tile phù hợp cho 1/2 để bake không làm đổi hình ô không mong muốn.</div>
            </div>

            <div class="control-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                <h2>Nhật Ký (Log)</h2>
                <div id="log-entries-container" class="log-entries">
                     <div id="initial-log-entry" class="log-entry">
                        <span class="log-timestamp"></span>Chào mừng! Hãy tải file map để bắt đầu.
                    </div>
                </div>
            </div>
        </div>
        
        <main id="canvas-container">
            <div id="welcome-message">
                <p>Vui lòng tải lên file bản đồ và ảnh tileset.</p>
            </div>
            <canvas id="map-canvas" style="display: none;"></canvas>
        </main>

    </div>

    <script type="module">
class MapData {
    mapName = "";
    mapVersion = 0;
    width = 0;
    height = 0;
    tilesetId = -1;
    tileMap = [];
    vgos = [];
    effectObjects = [];
    effData = [];
    internalVgoCount = null;
    collisionMap = [];
}

const TILE_SIZE = 24;

class BinaryReader {
    view;
    offset;
    textDecoder;

    constructor(buffer) {
        this.view = new DataView(buffer);
        this.offset = 0;
        this.textDecoder = new TextDecoder('utf-8');
    }

    readByte() { return this.view.getInt8(this.offset++); }
    readShort() { const val = this.view.getInt16(this.offset, false); this.offset += 2; return val; }
    readUShort() { const val = this.view.getUint16(this.offset, false); this.offset += 2; return val; }
    readUTF() {
        const len = this.readUShort();
        const strBytes = new Uint8Array(this.view.buffer, this.offset, len);
        this.offset += len;
        return this.textDecoder.decode(strBytes);
    }
    readBytes(num) {
        const bytes = new Uint8Array(this.view.buffer, this.offset, num);
        this.offset += num;
        return bytes;
    }
    seek(offset, from = 'start') {
        if (from === 'start') this.offset = offset;
        else this.offset += offset;
    }
    get eof() { return this.offset >= this.view.byteLength; }
    getBuffer() { return this.view.buffer; }
    getInt8At(offset) { return this.view.getInt8(offset); }
    getUint8At(offset) { return this.view.getUint8(offset); }
}

class BinaryWriter {
    byteList = [];
    textEncoder;

    constructor() { this.textEncoder = new TextEncoder(); }

    writeByte(value) { this.byteList.push(value & 0xFF); }
    writeShort(value) {
        const arr = new Uint8Array(2);
        new DataView(arr.buffer).setInt16(0, value, false);
        this.byteList.push(...Array.from(arr));
    }
    writeUTF(str) {
        const encoded = this.textEncoder.encode(str);
        this.writeShort(encoded.length);
        this.byteList.push(...Array.from(encoded));
    }
    writeBytes(bytes) { this.byteList.push(...Array.from(bytes)); }
    getBuffer() { return new Uint8Array(this.byteList).buffer; }
}

class MapViewerApp {
    canvas;
    ctx;
    canvasContainer;
    welcomeMessage;
    logEntriesContainer;
    saveMapButton;
    textDecoder;
    
    mapData = null;
    tilesetImage = null;
    effectIcons = new Map();

    scale = 1.0;
    panX = 0;
    panY = 0;

    isPanning = false;
    lastMouseX = 0;
    lastMouseY = 0;

    // Collision state
    showCollision = true;
    collisionMode = 'number';
    fThreshold = 32;
    gThreshold = 26;

    // Tile edit state
    isTileEditingMode = false;
    isPainting = false;
    selectedTileId = 1;

    // Collision edit state
    isCollisionEditingMode = false;
    collisionEditAction = 'cycle';

    constructor() {
        this.canvas = document.getElementById('map-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvasContainer = document.getElementById('canvas-container');
        this.welcomeMessage = document.getElementById('welcome-message');
        this.logEntriesContainer = document.getElementById('log-entries-container');
        this.saveMapButton = document.getElementById('save-map-button');
        this.textDecoder = new TextDecoder('utf-8');

        this.initEventListeners();
        this.log("Map viewer đã khởi tạo. Sẵn sàng nhận file.");
    }

    log(message) {
        if (!this.logEntriesContainer) return;
        const initialLog = document.getElementById('initial-log-entry');
        if(initialLog) initialLog.remove();
        const timestamp = new Date().toLocaleTimeString('vi-VN');
        const newEntry = document.createElement('div');
        newEntry.className = 'log-entry';
        newEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message.replace(/\n/g, '<br>')}`;
        this.logEntriesContainer.prepend(newEntry);
    }

    initEventListeners() {
        document.getElementById('map-input')?.addEventListener('change', this.handleMapFile.bind(this));
        document.getElementById('tileset-input')?.addEventListener('change', this.handleTilesetFile.bind(this));
        document.getElementById('icon-input')?.addEventListener('change', this.handleIconFiles.bind(this));
        this.saveMapButton.addEventListener('click', this.handleSaveMap.bind(this));

        document.getElementById('apply-resize-button')?.addEventListener('click', this.applyResizeFromUI.bind(this));
        
        // Collision controls
        const sc = document.getElementById('show-collision');
        const cm = document.getElementById('collision-mode');
        const ft = document.getElementById('f-threshold');
        const gt = document.getElementById('g-threshold');
        if (sc) sc.addEventListener('change', (e) => { this.showCollision = e.target.checked; this.render(); });
        if (cm) cm.addEventListener('change', (e) => { this.collisionMode = e.target.value; this.render(); });
        const onParam = () => { this.fThreshold = parseInt(ft.value||'32',10)||32; this.gThreshold = parseInt(gt.value||'26',10)||26; this.calculateCollisionMap(); this.render(); };
        if (ft) ft.addEventListener('input', onParam);
        if (gt) gt.addEventListener('input', onParam);
        
        // Tile edit controls
        const tem = document.getElementById('tile-edit-mode');
        const stid = document.getElementById('selected-tile-id');
        if (tem) tem.addEventListener('change', (e) => { this.isTileEditingMode = e.target.checked; this.isPainting = false; this.canvas.style.cursor = this.isTileEditingMode ? 'crosshair' : 'grab'; });
        // Collision edit controls
        const cem = document.getElementById('collision-edit-mode');
        const cea = document.getElementById('collision-edit-action');
        if (cem) cem.addEventListener('change', (e) => { this.isCollisionEditingMode = e.target.checked; this.canvas.style.cursor = this.isCollisionEditingMode ? 'crosshair' : (this.isTileEditingMode ? 'crosshair' : 'grab'); });
        if (cea) cea.addEventListener('change', (e) => { this.collisionEditAction = e.target.value; });
        const bakeBtn = document.getElementById('bake-collision-button');
        if (bakeBtn) bakeBtn.addEventListener('click', this.bakeCollisionIntoTiles.bind(this));
        this.blockedIdInput = document.getElementById('collision-blocked-id');
        this.waterIdInput = document.getElementById('collision-water-id');

        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
        window.addEventListener('resize', this.render.bind(this));
    }

    async handleMapFile(event) {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;
    
        const file = input.files[0];
        this.log(`Bắt đầu tải file map: ${file.name}`);
        try {
            const buffer = await file.arrayBuffer();
            this.mapData = new MapData();
            const reader = new BinaryReader(buffer);
            this.log("Đang phân tích dữ liệu file map...");
    
            reader.seek(2);
            this.mapData.mapName = reader.readUTF();
            this.mapData.mapVersion = reader.readShort(); 
            this.mapData.width = reader.readByte();
            this.mapData.height = reader.readByte();
            this.mapData.tilesetId = reader.readByte();
    
            this.log(`Thông tin map:\n- Tên: ${this.mapData.mapName}\n- Kích thước: ${this.mapData.width}x${this.mapData.height}\n- Tileset ID: ${this.mapData.tilesetId}\n- Version: 0x${this.mapData.mapVersion.toString(16).toUpperCase()}`);
            
            this.mapData.tileMap = [];
            const tileData = reader.readBytes(this.mapData.width * this.mapData.height);
            for (let y = 0; y < this.mapData.height; y++) {
                this.mapData.tileMap.push(Array.from(tileData.slice(y * this.mapData.width, (y + 1) * this.mapData.width)));
            }
            this.log(`Đã đọc ${this.mapData.tileMap.length * this.mapData.width} tiles.`);
    
            if (!reader.eof && reader.getInt8At(reader.offset) === -1) {
                reader.readByte();
            }

            if (!reader.eof) {
                const objectBlockLength = reader.readShort();
                const objectBlockStartOffset = reader.offset;
                if (objectBlockStartOffset + objectBlockLength > reader.getBuffer().byteLength) {
                    this.log("CẢNH BÁO: Object block length không hợp lệ, có thể file map bị lỗi.");
                } else {
                    const objectBlockBuffer = reader.getBuffer().slice(objectBlockStartOffset, objectBlockStartOffset + objectBlockLength);
                    const objectReader = new BinaryReader(objectBlockBuffer);
        
                    const numIcons = objectReader.readShort();
                    for (let i = 0; i < numIcons; i++) {
                        if (objectReader.offset + 6 > objectBlockBuffer.byteLength) break;
                        const templateId = objectReader.readShort();
                        this.mapData.effectObjects.push({
                            templateId: templateId,
                            x: objectReader.readShort() * TILE_SIZE,
                            y: objectReader.readShort() * TILE_SIZE,
                            text: "", name: `Effect ID: ${templateId}`
                        });
                    }
                    this.log(`Đã đọc ${this.mapData.effectObjects.length} đối tượng trang trí (Icons).`);
                    
                    // Try to parse CMD12 overlay key/value pairs first. If it fails, fallback to legacy internal format.
                    const tryParsePairs = () => {
                        const save = objectReader.offset;
                        try {
                            if (objectReader.offset + 2 > objectBlockBuffer.byteLength) return false;
                            const pairCount = objectReader.readShort();
                            if (pairCount < 0 || pairCount > 10000) { objectReader.offset = save; return false; }
                            let parsed = 0;
                            for (let i = 0; i < pairCount; i++) {
                                if (objectReader.offset + 2 > objectBlockBuffer.byteLength) throw new Error('overflow');
                                let keyLen = objectReader.readByte(); keyLen = (keyLen + 256) % 256;
                                if (objectReader.offset + keyLen > objectBlockBuffer.byteLength) throw new Error('overflow');
                                const key = this.textDecoder.decode(objectReader.readBytes(keyLen));
                                let valLen = objectReader.readByte(); valLen = (valLen + 256) % 256;
                                if (objectReader.offset + valLen > objectBlockBuffer.byteLength) throw new Error('overflow');
                                const val = this.textDecoder.decode(objectReader.readBytes(valLen));
                                if (key === 'eff') {
                                    const effString = val;
                                    const parts = effString.split(';');
                                    if (parts.length >= 4) {
                                        const id = parseInt(parts[1], 10);
                                        const x = parseInt(parts[2], 10);
                                        const y = parseInt(parts[3], 10);
                                        if (!isNaN(id) && !isNaN(x) && !isNaN(y)) {
                                            this.mapData.effData.push({ id, x: x * TILE_SIZE, y: y * TILE_SIZE, name: `Eff ID: ${id}`, text: `Eff: ${id}`, raw: effString });
                                        }
                                    }
                                } else if (key === 'vgo') {
                                    const parts = val.split(';');
                                    if (parts.length >= 4) {
                                        const tx = parseInt(parts[0], 10);
                                        const ty = parseInt(parts[1], 10);
                                        const name = parts[2] || '';
                                        const type = parseInt(parts[3], 10) || 0;
                                        if (!isNaN(tx) && !isNaN(ty)) {
                                            this.mapData.vgos.push({ x: tx * TILE_SIZE, y: ty * TILE_SIZE, name, mapGoId: type, xNew: 0, yNew: 0 });
                                        }
                                    }
                                }
                                parsed++;
                            }
                            this.log(`Đã đọc ${parsed} cặp chuỗi (overlay pairs).`);
                            return true;
                        } catch (e) {
                            objectReader.offset = save;
                            return false;
                        }
                    };

                    if (!tryParsePairs()) {
                        // Legacy internal format fallback
                        if (objectReader.offset + 2 <= objectReader.getBuffer().byteLength) {
                            this.mapData.internalVgoCount = objectReader.readShort();
                            this.log(`Đã đọc trường internal VGO count, giá trị: ${this.mapData.internalVgoCount}.`);
                        } else {
                            this.mapData.internalVgoCount = 0;
                        }
        
                        const effMagicNumber = [0x03, 0x65, 0x66, 0x66];
                        while (!objectReader.eof) {
                            const currentOffset = objectReader.offset;
                            if (currentOffset + 4 > objectReader.getBuffer().byteLength) break;
                            
                            const isEff = objectReader.getUint8At(currentOffset) === effMagicNumber[0] &&
                                            objectReader.getUint8At(currentOffset + 1) === effMagicNumber[1] &&
                                            objectReader.getUint8At(currentOffset + 2) === effMagicNumber[2] &&
                                            objectReader.getUint8At(currentOffset + 3) === effMagicNumber[3];
        
                            if (isEff) {
                                objectReader.seek(4, 'current');
                                try {
                                    const dataLength = objectReader.readByte();
                                    if (objectReader.offset + dataLength > objectReader.getBuffer().byteLength) break;
                                    const effStringBytes = objectReader.readBytes(dataLength);
                                    const effString = this.textDecoder.decode(effStringBytes);
                                    const parts = effString.split(';');
                                    if (parts.length >= 4) {
                                        const [id, x, y] = [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])];
                                        if (!isNaN(id) && !isNaN(x) && !isNaN(y)) {
                                             this.mapData.effData.push({ id, x: x * TILE_SIZE, y: y * TILE_SIZE, name: `Eff ID: ${id}`, text: `Eff: ${id}`, raw: effString });
                                        }
                                    }
                                } catch (e) { break; }
                            } else if (objectReader.getBuffer().byteLength - currentOffset >= 5) {
                                try {
                                    const vgoX = objectReader.readShort();
                                    const vgoY = objectReader.readShort();
                                    const vgoType = objectReader.readByte();
                                    let name = "";
                                    if (vgoType === 0) {
                                        const nameLen = objectReader.readByte();
                                        name = this.textDecoder.decode(objectReader.readBytes(nameLen));
                                    } else if (vgoType === 1) {
                                        name = objectReader.readUTF();
                                    } else { break; }
                                    this.mapData.vgos.push({ x: vgoX * TILE_SIZE, y: vgoY * TILE_SIZE, name, mapGoId: vgoType + 1, xNew: 0, yNew: 0 });
                                } catch (e) { break; }
                            } else { break; }
                        }
                        this.log(`Đã đọc ${this.mapData.vgos.length} VGOs và ${this.mapData.effData.length} 'eff' blocks.`);
                    }
                    reader.seek(objectBlockStartOffset + objectBlockLength, 'start');
                }
            }
    
            if (!reader.eof) {
                try {
                    const vgoCount = reader.readByte();
                    if (vgoCount > 0 && vgoCount < 100) {
                        for (let i = 0; i < vgoCount; i++) {
                            const x = reader.readShort();
                            const y = reader.readShort();
                            const name = reader.readUTF();
                            this.mapData.vgos.push({ x, y, name, mapGoId: 100, xNew: 0, yNew: 0 });
                        }
                        this.log(`Đã đọc ${vgoCount} VGOs bên ngoài.`);
                    }
                } catch (e) { /* No external VGO block */ }
            }

            document.getElementById('new-width-input').value = String(this.mapData.width);
            document.getElementById('new-height-input').value = String(this.mapData.height);

            this.saveMapButton.disabled = false;

            this.canvas.style.display = 'block';
            this.welcomeMessage.style.display = 'none';

            // Compute collision map initially
            this.calculateCollisionMap();

            this.resetView();
            this.render();
            this.log(`Hoàn tất tải map '${this.mapData.mapName}'. Sẵn sàng để xem.`);
        } catch (error) {
            console.error("Lỗi khi phân tích file map:", error);
            this.log(`LỖI: Không thể phân tích file map. Chi tiết trong console.`);
        }
    }

    async handleTilesetFile(event) {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        this.log(`Đang tải file tileset: ${file.name}...`);
        this.tilesetImage = new Image();
        this.tilesetImage.onload = () => {
            this.log(`Tải thành công tileset '${file.name}'. Vẽ lại bản đồ.`);
            this.populateTilePalette();
            const panel = document.getElementById('tile-palette-panel');
            if (panel) panel.style.display = 'block';
            this.render();
        };
        this.tilesetImage.onerror = () => {
             this.log(`LỖI: Không thể tải ảnh tileset '${file.name}'.`);
             this.tilesetImage = null;
        }
        this.tilesetImage.src = URL.createObjectURL(file);
    }

    async handleIconFiles(event) {
        const input = event.target;
        if (!input.files) return;

        const files = Array.from(input.files);
        if (files.length === 0) {
            this.log("Không có file icon nào được chọn.");
            return;
        }

        this.log(`Bắt đầu tải ${files.length} file icon...`);
        let loadedCount = 0;
        let failedCount = 0;
        const totalFiles = files.length;

        for (const file of files) {
            const iconId = parseInt(file.name.split('.')[0]);
            if (!isNaN(iconId)) {
                const image = new Image();
                image.src = URL.createObjectURL(file);
                const promise = new Promise((resolve, reject) => {
                    image.onload = resolve;
                    image.onerror = reject;
                });

                try {
                    await promise;
                    this.effectIcons.set(iconId, image);
                    loadedCount++;
                } catch {
                    failedCount++;
                }
            } else {
                failedCount++;
            }
        }
        
        this.log(`Hoàn tất tải icons. Thành công: ${loadedCount}, Thất bại: ${failedCount}. Vẽ lại bản đồ.`);
        this.render();
    }
    
    async handleSaveMap() {
        if (!this.mapData) { this.log("LỖI: Không có dữ liệu map để lưu."); return; }
        const width = (this.mapData.width | 0);
        const height = (this.mapData.height | 0);
        const k = (this.mapData.tilesetId | 0) & 0xFF;
        if (width <= 0 || height <= 0 || width > 255 || height > 255) {
            this.log(`LỖI: Kích thước không hợp lệ (w=${width}, h=${height}). Phải nằm trong [1..255].`);
            return;
        }
        this.log(`Xuất định dạng client (CMD 12)... (w=${width}, h=${height}, k=${k})`);
        try {
            const clampByte = (v) => Math.max(0, Math.min(255, v | 0));

            const tileBlobWriter = new BinaryWriter();
            tileBlobWriter.writeByte(width);
            tileBlobWriter.writeByte(height);
            tileBlobWriter.writeByte(k);
            for (let y = 0; y < height; y++) {
                const row = (this.mapData.tileMap[y] || []).slice(0, width);
                while (row.length < width) row.push(0);
                for (let x = 0; x < width; x++) tileBlobWriter.writeByte(clampByte(row[x]));
            }
            const tileBlob = new Uint8Array(tileBlobWriter.getBuffer());

            const overlayWriter = new BinaryWriter();
            const icons = Array.isArray(this.mapData.effectObjects) ? this.mapData.effectObjects : [];
            const validIcons = icons.filter(o => Number.isFinite(o.templateId) && (o.templateId|0) >= 0);
            overlayWriter.writeShort(validIcons.length);
            for (const obj of validIcons) {
                let xTile = Math.round((obj.x || 0) / TILE_SIZE);
                let yTile = Math.round((obj.y || 0) / TILE_SIZE);
                if (xTile < 0) xTile = 0; if (xTile >= width) xTile = width - 1;
                if (yTile < 0) yTile = 0; if (yTile >= height) yTile = height - 1;
                overlayWriter.writeShort((obj.templateId | 0));
                overlayWriter.writeShort(xTile);
                overlayWriter.writeShort(yTile);
            }
            // Append string pairs (eff, vgo)
            const encoder = new TextEncoder();
            const internalVgos = (Array.isArray(this.mapData.vgos) ? this.mapData.vgos : []).filter(v => (v.mapGoId|0) < 100);
            const effs = Array.isArray(this.mapData.effData) ? this.mapData.effData : [];
            const pairs = [];
            for (const e of effs) {
                if (!e || !e.raw) continue;
                const keyBytes = encoder.encode('eff');
                const valBytes = encoder.encode(String(e.raw));
                if (keyBytes.length <= 255 && valBytes.length <= 255) pairs.push([keyBytes, valBytes]);
            }
            for (const v of internalVgos) {
                const keyBytes = encoder.encode('vgo');
                const xTile = Math.max(0, Math.min(width - 1, Math.round((v.x || 0) / TILE_SIZE)));
                const yTile = Math.max(0, Math.min(height - 1, Math.round((v.y || 0) / TILE_SIZE)));
                const type = Math.max(0, (v.mapGoId|0));
                const name = String(v.name || '');
                const valBytes = encoder.encode(`${xTile};${yTile};${name};${type}`);
                if (keyBytes.length <= 255 && valBytes.length <= 255) pairs.push([keyBytes, valBytes]);
            }
            overlayWriter.writeShort(pairs.length);
            for (const [keyBytes, valBytes] of pairs) {
                overlayWriter.writeByte(keyBytes.length);
                overlayWriter.writeBytes(keyBytes);
                overlayWriter.writeByte(valBytes.length);
                overlayWriter.writeBytes(valBytes);
            }
            const overlayBlob = new Uint8Array(overlayWriter.getBuffer());

            const out = new BinaryWriter();
            out.writeShort(0);
            out.writeUTF(this.mapData.mapName || "");
            out.writeShort(tileBlob.length);
            out.writeBytes(tileBlob);
            out.writeByte(-1);
            out.writeShort(overlayBlob.length);
            out.writeBytes(overlayBlob);
            // Points of interest (external VGOs)
            {
                const exVgos = (Array.isArray(this.mapData.vgos) ? this.mapData.vgos : []).filter(v => (v.mapGoId|0) >= 100);
                const poiCount = Math.min(100, exVgos.length);
                out.writeByte(poiCount);
                for (let i = 0; i < poiCount; i++) {
                    const v = exVgos[i];
                    const px = Math.max(0, Math.min(0x7FFF, v.x|0));
                    const py = Math.max(0, Math.min(0x7FFF, v.y|0));
                    out.writeShort(px);
                    out.writeShort(py);
                    out.writeUTF(String(v.name || ''));
                }
            }
            
            out.writeByte(-1);
            
            const blob = new Blob([out.getBuffer()], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${this.mapData.tilesetId || 'map'}.bin`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);

            this.log(`Thành công! Xuất client: tileBlob=${tileBlob.length}B, overlay=${overlayBlob.length}B.`);
        } catch (error) {
            this.log(`LỖI NGHIÊM TRỌNG khi xuất client: ${error}`);
            console.error("Lỗi khi xuất định dạng client:", error);
        }
    }

    applyResizeFromUI() {
        if (!this.mapData) { this.log("LỖI: Chưa có map."); return; }
        const newW = Math.max(1, parseInt(document.getElementById('new-width-input').value || '0', 10));
        const newH = Math.max(1, parseInt(document.getElementById('new-height-input').value || '0', 10));
        const anchor = 'top-left'; // force append-style expansion for client safety
        const fillTile = Math.max(0, Math.min(255, parseInt(document.getElementById('fill-tile-input').value || '0', 10)));
        const clip = document.getElementById('clip-objects-checkbox').checked;
        this.resizeMap(newW, newH, anchor, fillTile, clip);
    }

    resizeMap(newWidth, newHeight, anchor, fillTileId, clipOutside) {
        const oldWidth = this.mapData.width;
        const oldHeight = this.mapData.height;

        let offsetX = 0, offsetY = 0;
        if (anchor === 'center') {
            offsetX = Math.floor((newWidth - oldWidth) / 2);
            offsetY = Math.floor((newHeight - oldHeight) / 2);
        } else if (anchor === 'bottom-right') {
            offsetX = newWidth - oldWidth;
            offsetY = newHeight - oldHeight;
        } // top-left => 0,0

        const newTileMap = new Array(newHeight);
        for (let y = 0; y < newHeight; y++) {
            const row = new Array(newWidth);
            for (let x = 0; x < newWidth; x++) {
                const srcX = x - offsetX;
                const srcY = y - offsetY;
                if (srcX >= 0 && srcX < oldWidth && srcY >= 0 && srcY < oldHeight) {
                    row[x] = this.mapData.tileMap[srcY][srcX] | 0;
                } else {
                    row[x] = fillTileId | 0;
                }
            }
            newTileMap[y] = row;
        }

        const dx = offsetX * TILE_SIZE;
        const dy = offsetY * TILE_SIZE;
        const maxX = newWidth * TILE_SIZE;
        const maxY = newHeight * TILE_SIZE;

        const inBounds = (x, y) => x >= 0 && y >= 0 && x < maxX && y < maxY;

        this.mapData.effectObjects = this.mapData.effectObjects.map(o => ({ ...o, x: o.x + dx, y: o.y + dy }))
            .filter(o => !clipOutside || inBounds(o.x, o.y));

        this.mapData.effData = this.mapData.effData.map(o => ({ ...o, x: o.x + dx, y: o.y + dy }))
            .filter(o => !clipOutside || inBounds(o.x, o.y));

        this.mapData.vgos = this.mapData.vgos.map(v => ({ ...v, x: v.x + dx, y: v.y + dy }))
            .filter(v => !clipOutside || inBounds(v.x, v.y));

        this.mapData.tileMap = newTileMap;
        this.mapData.width = newWidth;
        this.mapData.height = newHeight;

        // Recompute collision after resize
        this.calculateCollisionMap();

        this.log(`Đã thay đổi kích thước: ${oldWidth}x${oldHeight} -> ${newWidth}x${newHeight}. Anchor: ${anchor}. Offset (tile): (${offsetX}, ${offsetY}).`);
        this.resetView();
        this.render();
    }

    calculateCollisionMap() {
        if (!this.mapData || !this.mapData.tileMap.length) {
            if (this.mapData) this.mapData.collisionMap = [];
            return;
        }
        const { width, height, tilesetId, tileMap } = this.mapData;
        const raw = Array(height).fill(null).map(() => Array(width).fill(0));
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const id = tileMap[y][x] | 0; // 1-based; 0 = empty
                let c = 0;
                if (tilesetId < 9) {
                    if (id >= this.fThreshold || id === 0) c = 1;
                    else if (id >= this.gThreshold) c = 2;
                } else {
                    if (id >= this.fThreshold || id === 0) c = 1;
                }
                raw[y][x] = c;
            }
        }
        // Simple flood-fill: expand water (2) into adjacent lakebed tiles
        const fin = raw.map(r => r.slice());
        const q = [];
        for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) if (raw[y][x] === 2) q.push({x,y});
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        const lakeBedIds = new Set([32,33,34,35]);
        while (q.length) {
            const { x, y } = q.shift();
            for (const [dx, dy] of dirs) {
                const nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;
                if (fin[ny][nx] === 1 && lakeBedIds.has((tileMap[ny][nx] | 0))) {
                    fin[ny][nx] = 2;
                    q.push({ x: nx, y: ny });
                }
            }
        }
        this.mapData.collisionMap = fin;
        this.log("Đã cập nhật bản đồ va chạm (0/1/2).");
    }

    resetView() {
        if (!this.mapData) return;
        this.scale = 1.0;
        const containerWidth = this.canvasContainer.clientWidth;
        const containerHeight = this.canvasContainer.clientHeight;
        const mapPixelWidth = this.mapData.width * TILE_SIZE;
        const mapPixelHeight = this.mapData.height * TILE_SIZE;

        this.scale = Math.min(containerWidth / mapPixelWidth, containerHeight / mapPixelHeight, 1.0) * 0.95;
        this.panX = (containerWidth - mapPixelWidth * this.scale) / 2;
        this.panY = (containerHeight - mapPixelHeight * this.scale) / 2;
        this.log(`View đã reset. Scale: ${this.scale.toFixed(2)}, Pan: (${this.panX.toFixed(0)}, ${this.panY.toFixed(0)})`);
    }

    handleWheel(event) {
        if (!this.mapData) return;
        event.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1;
        const newScale = Math.max(0.1, Math.min(this.scale * zoomFactor, 10.0));
        
        this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
        this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
        this.scale = newScale;
        
        this.render();
    }

    handleMouseDown(event) {
        if (!this.mapData) return;
        if (event.button !== 0) return;
        const rect = this.canvas.getBoundingClientRect();
        const sx = event.clientX - rect.left;
        const sy = event.clientY - rect.top;
        const { x: mx, y: my } = this.screenToMapCoords(sx, sy);
        if (this.isTileEditingMode) {
            this.isPainting = true;
            this.paintTileAt(mx, my);
            return;
        }
        if (this.isCollisionEditingMode) {
            this.applyCollisionEditAt(mx, my);
            return;
        }
        this.isPanning = true;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.canvas.classList.add('grabbing');
    }

    handleMouseMove(event) {
        const rect = this.canvas.getBoundingClientRect();
        const sx = event.clientX - rect.left;
        const sy = event.clientY - rect.top;
        const { x: mx, y: my } = this.screenToMapCoords(sx, sy);
        if (this.isTileEditingMode && this.isPainting) {
            this.paintTileAt(mx, my);
            return;
        }
        if (!this.isPanning) return;
        const dx = event.clientX - this.lastMouseX;
        const dy = event.clientY - this.lastMouseY;
        this.panX += dx;
        this.panY += dy;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.render();
    }
    
    handleMouseUp() {
        this.isPainting = false;
        this.isPanning = false;
        this.canvas.classList.remove('grabbing');
    }

    render() {
        requestAnimationFrame(() => {
            if (!this.mapData) return;
            this.canvas.width = this.canvasContainer.clientWidth;
            this.canvas.height = this.canvasContainer.clientHeight;
            
            this.ctx.save();
            this.ctx.imageSmoothingEnabled = false;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.translate(this.panX, this.panY);
            this.ctx.scale(this.scale, this.scale);
            
            this.drawTileMap();
            this.drawCollisionLayer();
            this.drawObjects();

            this.ctx.restore();
        });
    }
    
    drawTileMap() {
        if (!this.mapData) return;

        if (!this.tilesetImage) {
            this.ctx.strokeStyle = '#555';
            this.ctx.lineWidth = 1 / this.scale;
            for (let y = 0; y < this.mapData.height; y++) {
                for (let x = 0; x < this.mapData.width; x++) {
                    this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
            return;
        }

        const tilesetCols = this.tilesetImage.width / TILE_SIZE;
        for (let y = 0; y < this.mapData.height; y++) {
            for (let x = 0; x < this.mapData.width; x++) {
                const tileId = (this.mapData.tileMap[y][x] | 0) - 1;
                if (tileId < 0) continue;

                const sx = (tileId % tilesetCols) * TILE_SIZE;
                const sy = Math.floor(tileId / tilesetCols) * TILE_SIZE;

                this.ctx.drawImage(
                    this.tilesetImage,
                    sx, sy, TILE_SIZE, TILE_SIZE,
                    x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE
                );
            }
        }
    }

    drawCollisionLayer() {
        if (!this.showCollision || !this.mapData || !this.mapData.collisionMap.length) return;
        const cm = this.mapData.collisionMap;
        for (let y = 0; y < cm.length; y++) {
            for (let x = 0; x < cm[y].length; x++) {
                const c = cm[y][x];
                const rectX = x * TILE_SIZE;
                const rectY = y * TILE_SIZE;
                if (this.collisionMode === 'color') {
                    if (c === 1) {
                        this.ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                        this.ctx.fillRect(rectX, rectY, TILE_SIZE, TILE_SIZE);
                    } else if (c === 2) {
                        this.ctx.fillStyle = 'rgba(59, 130, 246, 0.4)';
                        this.ctx.fillRect(rectX, rectY, TILE_SIZE, TILE_SIZE);
                    }
                } else {
                    const centerX = rectX + TILE_SIZE / 2;
                    const centerY = rectY + TILE_SIZE / 2;
                    this.ctx.font = `bold ${12 / this.scale}px sans-serif`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 3 / this.scale;
                    if (c === 1) {
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        this.ctx.fillStyle = '#fca5a5';
                    } else if (c === 2) {
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        this.ctx.fillStyle = '#93c5fd';
                    } else {
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    }
                    this.ctx.strokeText(String(c), centerX, centerY);
                    this.ctx.fillText(String(c), centerX, centerY);
                }
            }
        }
    }

    drawObjects() {
        if (!this.mapData) return;
        
        const allObjects = [
            ...this.mapData.effectObjects,
            ...this.mapData.vgos,
            ...this.mapData.effData,
        ].sort((a,b) => a.y - b.y);

        allObjects.forEach(obj => {
            if ('templateId' in obj) this.drawEffect(obj);
            else if ('mapGoId' in obj) this.drawVgo(obj);
            else if ('raw' in obj) this.drawEff(obj);
        });
    }

    drawVgo(vgo) {
        const centerX = vgo.x + TILE_SIZE / 2;
        const centerY = vgo.y + TILE_SIZE / 2;

        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, TILE_SIZE / 2, 0, 2 * Math.PI);
        this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
        this.ctx.fill();
        this.ctx.strokeStyle = '#2563EB';
        this.ctx.lineWidth = 1.5 / this.scale;
        this.ctx.stroke();

        if (vgo.name) {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = `bold ${11 / this.scale}px sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'bottom';
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 2.5 / this.scale;
            const textY = vgo.y - (4 / this.scale);
            this.ctx.strokeText(vgo.name, centerX, textY);
            this.ctx.fillText(vgo.name, centerX, textY);
        }
    }
    
    drawEff(eff) {
        this.ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
        this.ctx.strokeStyle = '#22c55e';
        this.ctx.lineWidth = 1 / this.scale;
        this.ctx.fillRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
        this.ctx.strokeRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
        
        if (eff.text) {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = `bold ${14 / this.scale}px sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 3 / this.scale;
            const textX = eff.x + TILE_SIZE / 2;
            const textY = eff.y + TILE_SIZE / 2;
            this.ctx.strokeText(eff.text, textX, textY);
            this.ctx.fillText(eff.text, textX, textY);
        }
    }
    
    drawEffect(effect) {
        const icon = this.effectIcons.get(effect.templateId);

        if (icon && icon.complete) {
            const drawX = effect.x + (TILE_SIZE - icon.width) / 2;
            const drawY = effect.y + (TILE_SIZE - icon.height) / 2;
            this.ctx.drawImage(icon, drawX, drawY, icon.width, icon.height);
        } else {
            this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
            this.ctx.strokeStyle = '#cccc00';
            this.ctx.lineWidth = 1 / this.scale;
            this.ctx.fillRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
            this.ctx.strokeRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
        }
    }

    // --- Tile palette & editing ---
    populateTilePalette() {
        try {
            if (!this.tilesetImage) return;
            const container = document.getElementById('tile-palette-container');
            const selectedSpan = document.getElementById('selected-tile-id');
            if (!container || !selectedSpan) return;
            container.innerHTML = '';
            const cols = Math.floor(this.tilesetImage.width / TILE_SIZE);
            const rows = Math.floor(this.tilesetImage.height / TILE_SIZE);
            const total = cols * rows;
            const makeCanvas = (w,h) => { const c = document.createElement('canvas'); c.width=w; c.height=h; c.style.imageRendering='pixelated'; return c; };
            for (let i = 0; i < total; i++) {
                const tileId = i + 1;
                const c = makeCanvas(TILE_SIZE, TILE_SIZE);
                const ctx = c.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                const sx = (i % cols) * TILE_SIZE;
                const sy = Math.floor(i / cols) * TILE_SIZE;
                ctx.drawImage(this.tilesetImage, sx, sy, TILE_SIZE, TILE_SIZE, 0, 0, TILE_SIZE, TILE_SIZE);
                c.style.border = '1px solid #333';
                c.style.cursor = 'pointer';
                c.title = String(tileId);
                c.addEventListener('click', () => {
                    this.selectedTileId = tileId;
                    selectedSpan.textContent = String(tileId);
                });
                container.appendChild(c);
            }
        } catch {}
    }

    screenToMapCoords(screenX, screenY) {
        return {
            x: (screenX - this.panX) / this.scale,
            y: (screenY - this.panY) / this.scale,
        };
    }

    paintTileAt(mx, my) {
        if (!this.mapData) return;
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        if (tx < 0 || ty < 0 || tx >= this.mapData.width || ty >= this.mapData.height) return;
        if ((this.mapData.tileMap[ty][tx] | 0) === this.selectedTileId) return;
        this.mapData.tileMap[ty][tx] = this.selectedTileId | 0;
        this.calculateCollisionMap();
        this.render();
    }

    // --- Collision editing ---
    applyCollisionEditAt(mx, my) {
        if (!this.mapData || !this.mapData.collisionMap.length) return;
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        if (tx < 0 || ty < 0 || tx >= this.mapData.width || ty >= this.mapData.height) return;
        const current = this.mapData.collisionMap[ty][tx] | 0;
        let next = current;
        switch (this.collisionEditAction) {
            case 'cycle': next = (current + 1) % 3; break;
            case 'set-0': next = 0; break;
            case 'set-1': next = 1; break;
            case 'set-2': next = 2; break;
        }
        this.mapData.collisionMap[ty][tx] = next;
        this.render();
    }

    bakeCollisionIntoTiles() {
        if (!this.mapData || !this.mapData.collisionMap.length) return;
        const { width, height, tileMap } = this.mapData;
        const blockedId = Math.max(0, Math.min(255, parseInt((this.blockedIdInput?.value)||`${this.fThreshold}`, 10) || this.fThreshold));
        const waterId = Math.max(0, Math.min(255, parseInt((this.waterIdInput?.value)||`${this.gThreshold}`, 10) || this.gThreshold));
        let changed = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const col = this.mapData.collisionMap[y][x] | 0;
                const id = tileMap[y][x] | 0;
                let newId = id;
                if (col === 0) {
                    // choose a simple ground id (1) unless 1 collides with blockedId/waterId usage
                    newId = (id === 0 || id === blockedId || id === waterId) ? 1 : id;
                } else if (col === 1) {
                    newId = blockedId; // force to chosen blocked tile id
                } else if (col === 2) {
                    newId = waterId; // force to chosen water tile id
                }
                if (newId !== id) { tileMap[y][x] = newId; changed++; }
            }
        }
        this.calculateCollisionMap();
        this.render();
        this.log(`Bake va chạm hoàn tất. Tiles thay đổi: ${changed}.`);
    }
}

new MapViewerApp();
    </script>
</body>
</html>