<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSO Map Viewer</title>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2a2a2a;
            --primary-color: #4CAF50;
            --primary-hover: #5cb85c;
            --text-color: #f0f0f0;
            --text-muted: #888;
            --border-color: #444;
            --font-family: 'Inter', sans-serif;
        }
        html { font-family: var(--font-family); }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            font-family: var(--font-family);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        .sidebar {
            width: 350px;
            min-width: 300px;
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-y: auto;
            box-sizing: border-box;
        }
        header h1 {
            margin: 0 0 0.5rem 0;
            font-size: 1.75rem;
            color: var(--primary-color);
        }
        p.description {
            color: var(--text-muted);
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
        }
        h2 {
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin: 0 0 1rem 0;
        }
        .control-group {
            background-color: #222;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        .file-input-group {
            margin-bottom: 1rem;
        }
        .file-input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        input[type="file"], input[type="number"], select, input[type="text"] {
            width: 100%;
            background-color: #3e3e3e;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9rem;
        }
        input[type="file"]::file-selector-button {
            background-color: #555;
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 1rem;
        }
        input[type="file"]::file-selector-button:hover { background-color: #666; }

        .action-button {
            width: 100%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.2rem;
            border-radius: 4px;
            font-family: var(--font-family);
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            font-size: 1rem;
        }
        .action-button:hover:not(:disabled) { background-color: var(--primary-hover); }
        .action-button:disabled { background-color: #555; opacity: 0.6; cursor: not-allowed; }
        .log-entries {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--bg-color);
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column-reverse;
            min-height: 150px;
        }
        .log-entry { margin-bottom: 0.25rem; line-height: 1.4; color: #ccc; word-break: break-word; }
        .log-timestamp { color: var(--text-muted); margin-right: 0.5rem; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #map-canvas {
            display: block;
            background-color: var(--bg-color);
            cursor: grab;
        }
        #map-canvas.grabbing {
            cursor: grabbing;
        }
        #welcome-message {
            color: var(--text-muted);
            text-align: center;
            font-size: 1.2rem;
        }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .inline { display: flex; gap: 0.5rem; align-items: center; }
        .small-muted { color: var(--text-muted); font-size: 0.8rem; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <header>
                <h1>HSO Map Viewer</h1>
                <p class="description">Tải file map và tileset tương ứng để xem bản đồ một cách trực quan.</p>
            </header>
    
            <div class="control-group">
                <h2>1. Tải File</h2>
                <div class="file-input-group">
                    <label id="map-label" for="map-input">File Bản Đồ (.map)</label>
                    <input type="file" id="map-input" accept=".map,.*">
                </div>
                 <div class="file-input-group">
                    <label id="tileset-label" for="tileset-input">Ảnh Tileset (.png)</label>
                    <input type="file" id="tileset-input" accept=".png">
                </div>
                 <div class="file-input-group">
                    <label for="icon-input">Ảnh Icons (.png)</label>
                    <input type="file" id="icon-input" accept=".png" multiple>
                </div>
            </div>

            <div class="control-group">
                <h2>2. Lưu Bản Đồ</h2>
                <button id="save-map-button" class="action-button" disabled>Lưu Dữ Liệu Map</button>
            </div>

            <div class="control-group">
                <h2>3. Chỉnh Kích Thước</h2>
                <div class="grid-2">
                    <div>
                        <label for="new-width-input">Chiều rộng mới (tiles)</label>
                        <input id="new-width-input" type="number" min="1" step="1" placeholder="width">
                    </div>
                    <div>
                        <label for="new-height-input">Chiều cao mới (tiles)</label>
                        <input id="new-height-input" type="number" min="1" step="1" placeholder="height">
                    </div>
                </div>
                <div class="file-input-group">
                    <label for="anchor-select">Neo giữ (anchor)</label>
                    <select id="anchor-select">
                        <option value="top-left">Giữ góc trái trên</option>
                        <option value="center" selected>Giữ giữa</option>
                        <option value="bottom-right">Giữ góc phải dưới</option>
                    </select>
                </div>
                <div class="grid-2">
                    <div>
                        <label for="fill-tile-input">Tile mặc định khi mở rộng</label>
                        <input id="fill-tile-input" type="number" min="0" max="255" step="1" value="0">
                    </div>
                    <div class="inline" style="margin-top: 1.8rem;">
                        <input id="clip-objects-checkbox" type="checkbox" checked>
                        <label for="clip-objects-checkbox">Xóa đối tượng nằm ngoài</label>
                    </div>
                </div>
                <div class="small-muted" style="margin-top: 0.5rem;">
                    Lưu ý: Tile size = 24px. Tile = 0 sẽ để trống theo client.
                </div>
                <button id="apply-resize-button" class="action-button" style="margin-top: 0.75rem;">Áp dụng thay đổi</button>
            </div>

            <div class="control-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                <h2>Nhật Ký (Log)</h2>
                <div id="log-entries-container" class="log-entries">
                     <div id="initial-log-entry" class="log-entry">
                        <span class="log-timestamp"></span>Chào mừng! Hãy tải file map để bắt đầu.
                    </div>
                </div>
            </div>
        </div>
        
        <main id="canvas-container">
            <div id="welcome-message">
                <p>Vui lòng tải lên file bản đồ và ảnh tileset.</p>
            </div>
            <canvas id="map-canvas" style="display: none;"></canvas>
        </main>

    </div>

    <script type="module">
class MapData {
    mapName = "";
    mapVersion = 0;
    width = 0;
    height = 0;
    tilesetId = -1;
    tileMap = [];
    vgos = [];
    effectObjects = [];
    effData = [];
    internalVgoCount = null;
}

const TILE_SIZE = 24;

class BinaryReader {
    view;
    offset;
    textDecoder;

    constructor(buffer) {
        this.view = new DataView(buffer);
        this.offset = 0;
        this.textDecoder = new TextDecoder('utf-8');
    }

    readByte() { return this.view.getInt8(this.offset++); }
    readShort() { const val = this.view.getInt16(this.offset, false); this.offset += 2; return val; }
    readUShort() { const val = this.view.getUint16(this.offset, false); this.offset += 2; return val; }
    readUTF() {
        const len = this.readUShort();
        const strBytes = new Uint8Array(this.view.buffer, this.offset, len);
        this.offset += len;
        return this.textDecoder.decode(strBytes);
    }
    readBytes(num) {
        const bytes = new Uint8Array(this.view.buffer, this.offset, num);
        this.offset += num;
        return bytes;
    }
    seek(offset, from = 'start') {
        if (from === 'start') this.offset = offset;
        else this.offset += offset;
    }
    get eof() { return this.offset >= this.view.byteLength; }
    getBuffer() { return this.view.buffer; }
    getInt8At(offset) { return this.view.getInt8(offset); }
    getUint8At(offset) { return this.view.getUint8(offset); }
}

class BinaryWriter {
    byteList = [];
    textEncoder;

    constructor() { this.textEncoder = new TextEncoder(); }

    writeByte(value) { this.byteList.push(value & 0xFF); }
    writeShort(value) {
        const arr = new Uint8Array(2);
        new DataView(arr.buffer).setInt16(0, value, false);
        this.byteList.push(...Array.from(arr));
    }
    writeUTF(str) {
        const encoded = this.textEncoder.encode(str);
        this.writeShort(encoded.length);
        this.byteList.push(...Array.from(encoded));
    }
    writeBytes(bytes) { this.byteList.push(...Array.from(bytes)); }
    getBuffer() { return new Uint8Array(this.byteList).buffer; }
}

class MapViewerApp {
    canvas;
    ctx;
    canvasContainer;
    welcomeMessage;
    logEntriesContainer;
    saveMapButton;
    textDecoder;
    
    mapData = null;
    tilesetImage = null;
    effectIcons = new Map();

    scale = 1.0;
    panX = 0;
    panY = 0;

    isPanning = false;
    lastMouseX = 0;
    lastMouseY = 0;

    constructor() {
        this.canvas = document.getElementById('map-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvasContainer = document.getElementById('canvas-container');
        this.welcomeMessage = document.getElementById('welcome-message');
        this.logEntriesContainer = document.getElementById('log-entries-container');
        this.saveMapButton = document.getElementById('save-map-button');
        this.textDecoder = new TextDecoder('utf-8');

        this.initEventListeners();
        this.log("Map viewer đã khởi tạo. Sẵn sàng nhận file.");
    }

    log(message) {
        if (!this.logEntriesContainer) return;
        const initialLog = document.getElementById('initial-log-entry');
        if(initialLog) initialLog.remove();
        const timestamp = new Date().toLocaleTimeString('vi-VN');
        const newEntry = document.createElement('div');
        newEntry.className = 'log-entry';
        newEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message.replace(/\n/g, '<br>')}`;
        this.logEntriesContainer.prepend(newEntry);
    }

    initEventListeners() {
        document.getElementById('map-input')?.addEventListener('change', this.handleMapFile.bind(this));
        document.getElementById('tileset-input')?.addEventListener('change', this.handleTilesetFile.bind(this));
        document.getElementById('icon-input')?.addEventListener('change', this.handleIconFiles.bind(this));
        this.saveMapButton.addEventListener('click', this.handleSaveMap.bind(this));
        document.getElementById('apply-resize-button')?.addEventListener('click', this.applyResizeFromUI.bind(this));
        
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
        window.addEventListener('resize', this.render.bind(this));
    }

    async handleMapFile(event) {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;
    
        const file = input.files[0];
        this.log(`Bắt đầu tải file map: ${file.name}`);
        try {
            const buffer = await file.arrayBuffer();
            this.mapData = new MapData();
            const reader = new BinaryReader(buffer);
            this.log("Đang phân tích dữ liệu file map...");
    
            reader.seek(2);
            this.mapData.mapName = reader.readUTF();
            this.mapData.mapVersion = reader.readShort(); 
            this.mapData.width = reader.readByte();
            this.mapData.height = reader.readByte();
            this.mapData.tilesetId = reader.readByte();
    
            this.log(`Thông tin map:\n- Tên: ${this.mapData.mapName}\n- Kích thước: ${this.mapData.width}x${this.mapData.height}\n- Tileset ID: ${this.mapData.tilesetId}\n- Version: 0x${this.mapData.mapVersion.toString(16).toUpperCase()}`);
            
            this.mapData.tileMap = [];
            const tileData = reader.readBytes(this.mapData.width * this.mapData.height);
            for (let y = 0; y < this.mapData.height; y++) {
                this.mapData.tileMap.push(Array.from(tileData.slice(y * this.mapData.width, (y + 1) * this.mapData.width)));
            }
            this.log(`Đã đọc ${this.mapData.tileMap.length * this.mapData.width} tiles.`);
    
            if (!reader.eof && reader.getInt8At(reader.offset) === -1) {
                reader.readByte();
            }

            if (!reader.eof) {
                const objectBlockLength = reader.readShort();
                const objectBlockStartOffset = reader.offset;
                if (objectBlockStartOffset + objectBlockLength > reader.getBuffer().byteLength) {
                    this.log("CẢNH BÁO: Object block length không hợp lệ, có thể file map bị lỗi.");
                } else {
                    const objectBlockBuffer = reader.getBuffer().slice(objectBlockStartOffset, objectBlockStartOffset + objectBlockLength);
                    const objectReader = new BinaryReader(objectBlockBuffer);
        
                    const numIcons = objectReader.readShort();
                    for (let i = 0; i < numIcons; i++) {
                        if (objectReader.offset + 6 > objectBlockBuffer.byteLength) break;
                        const templateId = objectReader.readShort();
                        this.mapData.effectObjects.push({
                            templateId: templateId,
                            x: objectReader.readShort() * TILE_SIZE,
                            y: objectReader.readShort() * TILE_SIZE,
                            text: "", name: `Effect ID: ${templateId}`
                        });
                    }
                    this.log(`Đã đọc ${this.mapData.effectObjects.length} đối tượng trang trí (Icons).`);
        
                    if (objectReader.offset + 2 <= objectReader.getBuffer().byteLength) {
                        this.mapData.internalVgoCount = objectReader.readShort();
                        this.log(`Đã đọc trường internal VGO count, giá trị: ${this.mapData.internalVgoCount}.`);
                    } else {
                        this.mapData.internalVgoCount = 0;
                    }
        
                    const effMagicNumber = [0x03, 0x65, 0x66, 0x66];
                    while (!objectReader.eof) {
                        const currentOffset = objectReader.offset;
                        if (currentOffset + 4 > objectReader.getBuffer().byteLength) break;
                        
                        const isEff = objectReader.getUint8At(currentOffset) === effMagicNumber[0] &&
                                        objectReader.getUint8At(currentOffset + 1) === effMagicNumber[1] &&
                                        objectReader.getUint8At(currentOffset + 2) === effMagicNumber[2] &&
                                        objectReader.getUint8At(currentOffset + 3) === effMagicNumber[3];
        
                        if (isEff) {
                            objectReader.seek(4, 'current');
                            try {
                                const dataLength = objectReader.readByte();
                                if (objectReader.offset + dataLength > objectReader.getBuffer().byteLength) break;
                                const effStringBytes = objectReader.readBytes(dataLength);
                                const effString = this.textDecoder.decode(effStringBytes);
                                const parts = effString.split(';');
                                if (parts.length >= 4) {
                                    const [id, x, y] = [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])];
                                    if (!isNaN(id) && !isNaN(x) && !isNaN(y)) {
                                         this.mapData.effData.push({ id, x: x * TILE_SIZE, y: y * TILE_SIZE, name: `Eff ID: ${id}`, text: `Eff: ${id}`, raw: effString });
                                    }
                                }
                            } catch (e) { break; }
                        } else if (objectReader.getBuffer().byteLength - currentOffset >= 5) {
                            try {
                                const vgoX = objectReader.readShort();
                                const vgoY = objectReader.readShort();
                                const vgoType = objectReader.readByte();
                                let name = "";
                                if (vgoType === 0) {
                                    const nameLen = objectReader.readByte();
                                    name = this.textDecoder.decode(objectReader.readBytes(nameLen));
                                } else if (vgoType === 1) {
                                    name = objectReader.readUTF();
                                } else { break; }
                                this.mapData.vgos.push({ x: vgoX * TILE_SIZE, y: vgoY * TILE_SIZE, name, mapGoId: vgoType + 1, xNew: 0, yNew: 0 });
                            } catch (e) { break; }
                        } else { break; }
                    }
                    this.log(`Đã đọc ${this.mapData.vgos.length} VGOs và ${this.mapData.effData.length} 'eff' blocks.`);
                    reader.seek(objectBlockStartOffset + objectBlockLength, 'start');
                }
            }
    
            if (!reader.eof) {
                try {
                    const vgoCount = reader.readByte();
                    if (vgoCount > 0 && vgoCount < 100) {
                        for (let i = 0; i < vgoCount; i++) {
                            const x = reader.readShort();
                            const y = reader.readShort();
                            const name = reader.readUTF();
                            this.mapData.vgos.push({ x, y, name, mapGoId: 100, xNew: 0, yNew: 0 });
                        }
                        this.log(`Đã đọc ${vgoCount} VGOs bên ngoài.`);
                    }
                } catch (e) { /* No external VGO block */ }
            }

            document.getElementById('new-width-input').value = String(this.mapData.width);
            document.getElementById('new-height-input').value = String(this.mapData.height);

            this.saveMapButton.disabled = false;
            this.canvas.style.display = 'block';
            this.welcomeMessage.style.display = 'none';
            this.resetView();
            this.render();
            this.log(`Hoàn tất tải map '${this.mapData.mapName}'. Sẵn sàng để xem.`);
        } catch (error) {
            console.error("Lỗi khi phân tích file map:", error);
            this.log(`LỖI: Không thể phân tích file map. Chi tiết trong console.`);
        }
    }

    async handleTilesetFile(event) {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        this.log(`Đang tải file tileset: ${file.name}...`);
        this.tilesetImage = new Image();
        this.tilesetImage.onload = () => {
            this.log(`Tải thành công tileset '${file.name}'. Vẽ lại bản đồ.`);
            this.render();
        };
        this.tilesetImage.onerror = () => {
             this.log(`LỖI: Không thể tải ảnh tileset '${file.name}'.`);
             this.tilesetImage = null;
        }
        this.tilesetImage.src = URL.createObjectURL(file);
    }

    async handleIconFiles(event) {
        const input = event.target;
        if (!input.files) return;

        const files = Array.from(input.files);
        if (files.length === 0) {
            this.log("Không có file icon nào được chọn.");
            return;
        }

        this.log(`Bắt đầu tải ${files.length} file icon...`);
        let loadedCount = 0;
        let failedCount = 0;
        const totalFiles = files.length;

        for (const file of files) {
            const iconId = parseInt(file.name.split('.')[0]);
            if (!isNaN(iconId)) {
                const image = new Image();
                image.src = URL.createObjectURL(file);
                const promise = new Promise((resolve, reject) => {
                    image.onload = resolve;
                    image.onerror = reject;
                });

                try {
                    await promise;
                    this.effectIcons.set(iconId, image);
                    loadedCount++;
                } catch {
                    failedCount++;
                }
            } else {
                failedCount++;
            }
        }
        
        this.log(`Hoàn tất tải icons. Thành công: ${loadedCount}, Thất bại: ${failedCount}. Vẽ lại bản đồ.`);
        this.render();
    }
    
    async handleSaveMap() {
        if (!this.mapData) { this.log("LỖI: Không có dữ liệu map để lưu."); return; }
        const width = (this.mapData.width | 0);
        const height = (this.mapData.height | 0);
        const k = (this.mapData.tilesetId | 0) & 0xFF;
        if (width <= 0 || height <= 0 || width > 255 || height > 255) {
            this.log(`LỖI: Kích thước không hợp lệ (w=${width}, h=${height}). Phải nằm trong [1..255].`);
            return;
        }
        this.log(`Xuất định dạng client... (w=${width}, h=${height}, k=${k})`);
        try {
            const clampByte = (v) => Math.max(0, Math.min(255, v | 0));

            // Build tile blob: [w:1][h:1][k:1][w*h tiles]
            const tileBlobWriter = new BinaryWriter();
            tileBlobWriter.writeByte(width);
            tileBlobWriter.writeByte(height);
            tileBlobWriter.writeByte(k);
            for (let y = 0; y < height; y++) {
                const row = this.mapData.tileMap[y] || [];
                for (let x = 0; x < width; x++) {
                    const tile = row[x] ?? 0;
                    tileBlobWriter.writeByte(clampByte(tile));
                }
            }
            const tileBlob = new Uint8Array(tileBlobWriter.getBuffer());

            // Build overlay blob (icons only): [short countIcons] then (templateId:short, xTile:short, yTile:short)*
            const overlayWriter = new BinaryWriter();
            const icons = Array.isArray(this.mapData.effectObjects) ? this.mapData.effectObjects : [];
            overlayWriter.writeShort(icons.length);
            for (const obj of icons) {
                const xTile = Math.max(0, Math.min(32767, Math.round((obj.x || 0) / TILE_SIZE)));
                const yTile = Math.max(0, Math.min(32767, Math.round((obj.y || 0) / TILE_SIZE)));
                overlayWriter.writeShort(obj.templateId | 0);
                overlayWriter.writeShort(xTile);
                overlayWriter.writeShort(yTile);
            }
            const overlayBlob = new Uint8Array(overlayWriter.getBuffer());

            // Compose final client message:
            // [short mapId][short spawnX][short spawnY][short unk][UTF name]
            // [short lenTileBlob][tileBlob][byte -1][short lenOverlay][overlay]
            const out = new BinaryWriter();
            const mapId = 0;
            const spawnX = 0; // tile coordinate
            const spawnY = 0; // tile coordinate
            const unk = 0;    // reserved
            out.writeShort(mapId);
            out.writeShort(spawnX);
            out.writeShort(spawnY);
            out.writeShort(unk);
            out.writeUTF(this.mapData.mapName || "");
            out.writeShort(tileBlob.length);
            out.writeBytes(tileBlob);
            out.writeByte(-1); // no minimap/bg
            out.writeShort(overlayBlob.length);
            out.writeBytes(overlayBlob);

            const blob = new Blob([out.getBuffer()], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${this.mapData.tilesetId || 'map'}.bin`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);

            this.log(`Thành công! Xuất client bytes: tileBlob=${tileBlob.length}B, overlay=${overlayBlob.length}B.`);
        } catch (error) {
            this.log(`LỖI NGHIÊM TRỌNG khi xuất: ${error}`);
            console.error("Lỗi khi xuất định dạng client:", error);
        }
    }

    applyResizeFromUI() {
        if (!this.mapData) { this.log("LỖI: Chưa có map."); return; }
        const newW = Math.max(1, parseInt(document.getElementById('new-width-input').value || '0', 10));
        const newH = Math.max(1, parseInt(document.getElementById('new-height-input').value || '0', 10));
        const anchor = document.getElementById('anchor-select').value;
        const fillTile = Math.max(0, Math.min(255, parseInt(document.getElementById('fill-tile-input').value || '0', 10)));
        const clip = document.getElementById('clip-objects-checkbox').checked;
        this.resizeMap(newW, newH, anchor, fillTile, clip);
    }

    resizeMap(newWidth, newHeight, anchor, fillTileId, clipOutside) {
        const oldWidth = this.mapData.width;
        const oldHeight = this.mapData.height;

        let offsetX = 0, offsetY = 0;
        if (anchor === 'center') {
            offsetX = Math.floor((newWidth - oldWidth) / 2);
            offsetY = Math.floor((newHeight - oldHeight) / 2);
        } else if (anchor === 'bottom-right') {
            offsetX = newWidth - oldWidth;
            offsetY = newHeight - oldHeight;
        } // top-left => 0,0

        const newTileMap = new Array(newHeight);
        for (let y = 0; y < newHeight; y++) {
            const row = new Array(newWidth);
            for (let x = 0; x < newWidth; x++) {
                const srcX = x - offsetX;
                const srcY = y - offsetY;
                if (srcX >= 0 && srcX < oldWidth && srcY >= 0 && srcY < oldHeight) {
                    row[x] = this.mapData.tileMap[srcY][srcX] | 0;
                } else {
                    row[x] = fillTileId | 0;
                }
            }
            newTileMap[y] = row;
        }

        const dx = offsetX * TILE_SIZE;
        const dy = offsetY * TILE_SIZE;
        const maxX = newWidth * TILE_SIZE;
        const maxY = newHeight * TILE_SIZE;

        const inBounds = (x, y) => x >= 0 && y >= 0 && x < maxX && y < maxY;

        this.mapData.effectObjects = this.mapData.effectObjects.map(o => ({ ...o, x: o.x + dx, y: o.y + dy }))
            .filter(o => !clipOutside || inBounds(o.x, o.y));

        this.mapData.effData = this.mapData.effData.map(o => ({ ...o, x: o.x + dx, y: o.y + dy }))
            .filter(o => !clipOutside || inBounds(o.x, o.y));

        this.mapData.vgos = this.mapData.vgos.map(v => ({ ...v, x: v.x + dx, y: v.y + dy }))
            .filter(v => !clipOutside || inBounds(v.x, v.y));

        this.mapData.tileMap = newTileMap;
        this.mapData.width = newWidth;
        this.mapData.height = newHeight;

        this.log(`Đã thay đổi kích thước: ${oldWidth}x${oldHeight} -> ${newWidth}x${newHeight}. Anchor: ${anchor}. Offset (tile): (${offsetX}, ${offsetY}).`);
        this.resetView();
        this.render();
    }

    resetView() {
        if (!this.mapData) return;
        this.scale = 1.0;
        const containerWidth = this.canvasContainer.clientWidth;
        const containerHeight = this.canvasContainer.clientHeight;
        const mapPixelWidth = this.mapData.width * TILE_SIZE;
        const mapPixelHeight = this.mapData.height * TILE_SIZE;

        this.scale = Math.min(containerWidth / mapPixelWidth, containerHeight / mapPixelHeight, 1.0) * 0.95;
        this.panX = (containerWidth - mapPixelWidth * this.scale) / 2;
        this.panY = (containerHeight - mapPixelHeight * this.scale) / 2;
        this.log(`View đã reset. Scale: ${this.scale.toFixed(2)}, Pan: (${this.panX.toFixed(0)}, ${this.panY.toFixed(0)})`);
    }

    handleWheel(event) {
        if (!this.mapData) return;
        event.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1;
        const newScale = Math.max(0.1, Math.min(this.scale * zoomFactor, 10.0));
        
        this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
        this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
        this.scale = newScale;
        
        this.render();
    }

    handleMouseDown(event) {
        if (event.button !== 0 || !this.mapData) return;
        this.isPanning = true;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.canvas.classList.add('grabbing');
    }

    handleMouseMove(event) {
        if (!this.isPanning) return;
        const dx = event.clientX - this.lastMouseX;
        const dy = event.clientY - this.lastMouseY;
        this.panX += dx;
        this.panY += dy;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.render();
    }
    
    handleMouseUp() {
        this.isPanning = false;
        this.canvas.classList.remove('grabbing');
    }

    render() {
        requestAnimationFrame(() => {
            if (!this.mapData) return;
            this.canvas.width = this.canvasContainer.clientWidth;
            this.canvas.height = this.canvasContainer.clientHeight;
            
            this.ctx.save();
            this.ctx.imageSmoothingEnabled = false;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.translate(this.panX, this.panY);
            this.ctx.scale(this.scale, this.scale);
            
            this.drawTileMap();
            this.drawObjects();

            this.ctx.restore();
        });
    }
    
    drawTileMap() {
        if (!this.mapData) return;

        if (!this.tilesetImage) {
            this.ctx.strokeStyle = '#555';
            this.ctx.lineWidth = 1 / this.scale;
            for (let y = 0; y < this.mapData.height; y++) {
                for (let x = 0; x < this.mapData.width; x++) {
                    this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
            return;
        }

        const tilesetCols = this.tilesetImage.width / TILE_SIZE;
        for (let y = 0; y < this.mapData.height; y++) {
            for (let x = 0; x < this.mapData.width; x++) {
                const tileId = (this.mapData.tileMap[y][x] | 0) - 1;
                if (tileId < 0) continue;

                const sx = (tileId % tilesetCols) * TILE_SIZE;
                const sy = Math.floor(tileId / tilesetCols) * TILE_SIZE;

                this.ctx.drawImage(
                    this.tilesetImage,
                    sx, sy, TILE_SIZE, TILE_SIZE,
                    x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE
                );
            }
        }
    }

    drawObjects() {
        if (!this.mapData) return;
        
        const allObjects = [
            ...this.mapData.effectObjects,
            ...this.mapData.vgos,
            ...this.mapData.effData,
        ].sort((a,b) => a.y - b.y);

        allObjects.forEach(obj => {
            if ('templateId' in obj) this.drawEffect(obj);
            else if ('mapGoId' in obj) this.drawVgo(obj);
            else if ('raw' in obj) this.drawEff(obj);
        });
    }

    drawVgo(vgo) {
        const centerX = vgo.x + TILE_SIZE / 2;
        const centerY = vgo.y + TILE_SIZE / 2;

        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, TILE_SIZE / 2, 0, 2 * Math.PI);
        this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
        this.ctx.fill();
        this.ctx.strokeStyle = '#2563EB';
        this.ctx.lineWidth = 1.5 / this.scale;
        this.ctx.stroke();

        if (vgo.name) {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = `bold ${11 / this.scale}px sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'bottom';
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 2.5 / this.scale;
            const textY = vgo.y - (4 / this.scale);
            this.ctx.strokeText(vgo.name, centerX, textY);
            this.ctx.fillText(vgo.name, centerX, textY);
        }
    }
    
    drawEff(eff) {
        this.ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
        this.ctx.strokeStyle = '#22c55e';
        this.ctx.lineWidth = 1 / this.scale;
        this.ctx.fillRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
        this.ctx.strokeRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
        
        if (eff.text) {
            this.ctx.fillStyle = '#ffffff';
            this.ctx.font = `bold ${14 / this.scale}px sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.strokeStyle = 'black';
            this.ctx.lineWidth = 3 / this.scale;
            const textX = eff.x + TILE_SIZE / 2;
            const textY = eff.y + TILE_SIZE / 2;
            this.ctx.strokeText(eff.text, textX, textY);
            this.ctx.fillText(eff.text, textX, textY);
        }
    }
    
    drawEffect(effect) {
        const icon = this.effectIcons.get(effect.templateId);

        if (icon && icon.complete) {
            const drawX = effect.x + (TILE_SIZE - icon.width) / 2;
            const drawY = effect.y + (TILE_SIZE - icon.height) / 2;
            this.ctx.drawImage(icon, drawX, drawY, icon.width, icon.height);
        } else {
            this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
            this.ctx.strokeStyle = '#cccc00';
            this.ctx.lineWidth = 1 / this.scale;
            this.ctx.fillRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
            this.ctx.strokeRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
        }
    }
}

new MapViewerApp();
    </script>
</body>
</html>