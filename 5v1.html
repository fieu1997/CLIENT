<!DOCTYPE html>
<html lang="vi">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>HSO Map Viewer</title>
	<link rel="stylesheet" href="https://rsms.me/inter/inter.css">
	<style>
		:root {
			--bg-color: #1a1a1a;
			--surface-color: #2a2a2a;
			--primary-color: #4CAF50;
			--primary-hover: #5cb85c;
			--text-color: #f0f0f0;
			--text-muted: #888;
			--border-color: #444;
			--font-family: 'Inter', sans-serif;
		}
		html { font-family: var(--font-family); }
		body {
			background-color: var(--bg-color);
			color: var(--text-color);
			margin: 0;
			font-family: var(--font-family);
			display: flex;
			height: 100vh;
			overflow: hidden;
		}
		.app-container {
			display: flex;
			width: 100%;
			height: 100%;
		}
		.sidebar {
			width: 350px;
			min-width: 300px;
			background-color: var(--surface-color);
			padding: 1.5rem;
			border-right: 1px solid var(--border-color);
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
			overflow-y: auto;
			box-sizing: border-box;
		}
		header h1 {
			margin: 0 0 0.5rem 0;
			font-size: 1.75rem;
			color: var(--primary-color);
		}
		p.description {
			color: var(--text-muted);
			margin: 0 0 1rem 0;
			font-size: 0.9rem;
		}
		h2 {
			font-size: 1.1rem;
			font-weight: 600;
			border-bottom: 2px solid var(--primary-color);
			padding-bottom: 0.5rem;
			margin: 0 0 1rem 0;
		}
		.control-group {
			background-color: #222;
			padding: 1rem;
			border-radius: 6px;
			border: 1px solid var(--border-color);
		}
		.file-input-group { margin-bottom: 1rem; }
		.file-input-group label {
			display: block;
			margin-bottom: 0.5rem;
			font-weight: 500;
		}
		input[type="file"], input[type="number"], select, input[type="text"], textarea {
			width: 100%;
			background-color: #3e3e3e;
			color: var(--text-color);
			border: 1px solid var(--border-color);
			padding: 0.5rem;
			border-radius: 4px;
			box-sizing: border-box;
			font-size: 0.9rem;
		}
		input[type="file"]::file-selector-button {
			background-color: #555;
			color: var(--text-color);
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 4px;
			cursor: pointer;
			transition: background-color 0.2s;
			margin-right: 1rem;
		}
		input[type="file"]::file-selector-button:hover { background-color: #666; }

		.action-button {
			width: 100%;
			background-color: var(--primary-color);
			color: white;
			border: none;
			padding: 0.75rem 1.2rem;
			border-radius: 4px;
			font-family: var(--font-family);
			font-weight: 600;
			cursor: pointer;
			transition: background-color 0.2s, opacity 0.2s;
			font-size: 1rem;
		}
		.action-button:hover:not(:disabled) { background-color: var(--primary-hover); }
		.action-button:disabled { background-color: #555; opacity: 0.6; cursor: not-allowed; }
		.log-entries {
			flex-grow: 1;
			overflow-y: auto;
			background-color: var(--bg-color);
			padding: 0.75rem;
			border-radius: 4px;
			border: 1px solid var(--border-color);
			font-family: 'Courier New', Courier, monospace;
			font-size: 0.85rem;
			display: flex;
			flex-direction: column-reverse;
			min-height: 150px;
		}
		.log-entry { margin-bottom: 0.25rem; line-height: 1.4; color: #ccc; word-break: break-word; }
		.log-timestamp { color: var(--text-muted); margin-right: 0.5rem; }

		#canvas-container {
			flex-grow: 1;
			position: relative;
			background-color: #111;
			display: flex;
			justify-content: center;
			align-items: center;
		}
		#map-canvas { display: block; background-color: var(--bg-color); cursor: grab; }
		#map-canvas.grabbing { cursor: grabbing; }
		#welcome-message { color: var(--text-muted); text-align: center; font-size: 1.2rem; }
		.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
		.inline { display: flex; gap: 0.5rem; align-items: center; }
		.small-muted { color: var(--text-muted); font-size: 0.8rem; }

		/* NPC Modal */
		#npc-editor-modal {
			display: none;
			position: absolute;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #222;
			border: 1px solid var(--border-color);
			border-radius: 6px;
			padding: 16px;
			z-index: 1000;
			min-width: 420px;
			max-width: 540px;
			color: var(--text-color);
			box-shadow: 0 10px 30px rgba(0,0,0,0.6);
		}
		#npc-editor-modal h3 { margin: 0 0 12px 0; }
		#npc-editor-form label { font-size: 12px; color: #aaa; display: block; margin-bottom: 4px; }
		#npc-editor-form .field { margin-bottom: 8px; }
		#npc-editor-actions { display: flex; gap: 8px; margin-top: 8px; }
		.icon-preview { width: 48px; height: 48px; border: 1px solid var(--border-color); display:flex; align-items:center; justify-content:center; }
		/* Top toolbar and floating panel */
		#top-toolbar { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; background: var(--surface-color); border-bottom: 1px solid var(--border-color); display: flex; gap: 8px; align-items: center; padding: 8px 12px; }
		#top-toolbar .mode-button { background: #3a3a3a; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-weight: 600; }
		#top-toolbar .mode-button.active { background: var(--primary-color); border-color: var(--primary-color); color: #fff; }
		#top-toolbar .toolbar-group { display: flex; gap: 8px; }
		.app-container { margin-top: 48px; }
		.floating-panel { position: absolute; top: 80px; left: 420px; width: 420px; height: 360px; background: #1f1f1f; border: 1px solid var(--border-color); border-radius: 6px; box-shadow: 0 10px 30px rgba(0,0,0,0.6); z-index: 1200; display: flex; flex-direction: column; resize: both; overflow: hidden; }
		.floating-header { display: flex; align-items: center; justify-content: space-between; background: #2b2b2b; padding: 6px 10px; cursor: move; border-bottom: 1px solid var(--border-color); }
		.floating-title { font-weight: 700; color: var(--text-color); }
		.floating-controls { display: flex; gap: 6px; }
		.floating-controls button { background: #444; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; cursor: pointer; }
		.floating-controls button:hover { background: #555; }
		.floating-content { flex: 1; overflow: auto; padding: 10px; }
		.floating-panel.minimized { height: auto; }
		.floating-panel.minimized .floating-content { display: none; }
		.floating-content::-webkit-scrollbar { width: 8px; height: 8px; }
		.floating-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
		/* Hide sidebar to simplify UI */
		.sidebar { display: none; }
	</style>
</head>
<body>
	<div id="top-toolbar">
		<div class="toolbar-group">
			<button class="mode-button" data-mode="file">Tệp</button>
			<button class="mode-button" data-mode="resize">Kích thước</button>
			<button class="mode-button" data-mode="collision">Va chạm</button>
			<button class="mode-button" data-mode="log">Log</button>
		</div>
		<div class="toolbar-group">
			<button class="mode-button" data-mode="tile">Sửa Tile</button>
			<button class="mode-button" data-mode="icon">Icon</button>
			<button class="mode-button" data-mode="eff">Eff</button>
			<button class="mode-button" data-mode="vgo">VGO</button>
			<button class="mode-button" data-mode="npc">NPC</button>
		</div>
		<div class="toolbar-group" style="margin-left:auto; align-items:center;">
			<label class="inline" style="gap:6px; align-items:center;">
				<input type="checkbox" id="toggle-overlays" checked>
				<span>Hiện icon/Eff/NPC</span>
			</label>
		</div>
		<div style="display:flex; gap:8px;">
			<button id="top-undo-btn" class="mode-button" disabled>↶ Hoàn tác</button>
		</div>
	</div>
	<div class="app-container">
		<div class="sidebar">
			<header>
				<h1>HSO Map Viewer</h1>
				<p class="description">Tải file map và tileset tương ứng để xem bản đồ một cách trực quan.</p>
			</header>

			<div class="control-group" style="display:none;">
				<h2>1. Tải File</h2>
				<div class="file-input-group">
					<label id="map-label" for="map-input">File Bản Đồ (.map)</label>
					<input type="file" id="map-input" accept=".map,.*">
				</div>
				<div class="file-input-group">
					<label id="tileset-label" for="tileset-input">Ảnh Tileset (.png)</label>
					<input type="file" id="tileset-input" accept=".png">
				</div>
				<div class="file-input-group">
					<label for="icon-input">Ảnh Icons (.png)</label>
					<input type="file" id="icon-input" accept=".png" multiple webkitdirectory directory>
				</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>2. Lưu Bản Đồ</h2>
				<button id="save-map-button" class="action-button" disabled>Lưu Dữ Liệu (CMD 12)</button>
			</div>

			<div class="control-group" style="display:none;">
				<h2>Hoàn tác</h2>
				<button id="undo-button" class="action-button" disabled>↶ Hoàn tác</button>
			</div>

			<div class="control-group" style="display:none;">
				<h2>3. Chỉnh Kích Thước</h2>
				<div class="grid-2">
					<div>
						<label for="new-width-input">Chiều rộng mới (tiles)</label>
						<input id="new-width-input" type="number" min="1" step="1" placeholder="width">
					</div>
					<div>
						<label for="new-height-input">Chiều cao mới (tiles)</label>
						<input id="new-height-input" type="number" min="1" step="1" placeholder="height">
					</div>
				</div>
				<div class="file-input-group">
					<label for="anchor-select">Neo giữ (anchor)</label>
					<select id="anchor-select">
						<option value="top-left" selected>Giữ góc trái trên</option>
						<option value="center">Giữ giữa</option>
						<option value="bottom-right">Giữ góc phải dưới</option>
					</select>
				</div>
				<div class="grid-2">
					<div>
						<label for="fill-tile-input">Tile mặc định khi mở rộng</label>
						<input id="fill-tile-input" type="number" min="0" max="255" step="1" value="0">
					</div>
					<div class="inline" style="margin-top: 1.8rem;">
						<input id="clip-objects-checkbox" type="checkbox" checked>
						<label for="clip-objects-checkbox">Xóa đối tượng nằm ngoài</label>
					</div>
				</div>
				<div class="small-muted" style="margin-top: 0.5rem;">Lưu ý: Tile size = 24px. Tile = 0 sẽ để trống theo client.</div>
				<button id="apply-resize-button" class="action-button" style="margin-top: 0.75rem;">Áp dụng thay đổi</button>
			</div>

			<div class="control-group" style="display:none;">
				<h2>4. Va chạm</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="show-collision" checked>
					<label for="show-collision">Hiển thị lớp va chạm 0/1/2</label>
				</div>
				<div class="file-input-group">
					<label for="collision-mode">Chế độ hiển thị</label>
					<select id="collision-mode">
						<option value="number" selected>Hiển thị số</option>
						<option value="color">Tô màu</option>
					</select>
				</div>
				<div class="grid-2">
					<div>
						<label for="f-threshold">Ngưỡng F (chặn)</label>
						<input id="f-threshold" type="number" min="0" max="255" step="1" value="32">
					</div>
					<div>
						<label for="g-threshold">Ngưỡng G (nước)</label>
						<input id="g-threshold" type="number" min="0" max="255" step="1" value="26">
					</div>
				</div>
			</div>

			<div class="control-group" id="icon-palette-panel" style="display:none;">
				<h2>Danh sách Icon (0-999)</h2>
				<div id="icon-palette-container" style="display:grid; grid-template-columns: repeat(auto-fill, 32px); gap:6px; max-height:220px; overflow:auto;"></div>
				<div class="small-muted" style="margin-top: 0.5rem;">Kéo icon từ danh sách và thả vào map để thêm nhanh.</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>5. Chỉnh sửa Tile</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="tile-edit-mode">
					<label for="tile-edit-mode">Bật chế độ sửa tile (vẽ)</label>
				</div>
				<div class="small-muted">Tile đang chọn: <strong id="selected-tile-id">1</strong></div>
				<div id="tile-palette-panel" style="display:none; margin-top: 0.5rem; max-height:200px; overflow:auto;">
					<div id="tile-palette-container" style="display:grid; grid-template-columns: repeat(auto-fill, 24px); gap:4px;"></div>
				</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>6. Sửa Icon (0-999)</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="icon-edit-mode">
					<label for="icon-edit-mode">Bật chế độ sửa icon (kéo thả / xóa)</label>
				</div>
				<div class="file-input-group">
					<label for="icon-id-input">ID icon (0-999)</label>
					<input id="icon-id-input" type="number" min="0" max="999" step="1" value="0">
				</div>
				<div class="inline" style="gap: 0.5rem;">
					<button id="add-icon-button" class="action-button">Thêm icon</button>
					<button id="delete-icon-button" class="action-button" style="background-color:#d9534f;">Xóa icon đã chọn</button>
				</div>
				<div class="small-muted" style="margin-top: 0.5rem;">Mẹo: Bật chế độ sửa icon, click vào icon để chọn rồi kéo thả để đổi vị trí. Chuột phải lên icon để xóa nhanh.</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>7. Sửa Eff</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="eff-edit-mode">
					<label for="eff-edit-mode">Bật chế độ sửa eff (kéo thả / xóa)</label>
				</div>
				<div class="file-input-group">
					<label for="eff-id-input">ID eff</label>
					<input id="eff-id-input" type="number" min="0" max="9999" step="1" value="0">
				</div>
				<div class="inline" style="gap: 0.5rem;">
					<button id="add-eff-button" class="action-button">Thêm eff</button>
					<button id="delete-eff-button-eff" class="action-button" style="background-color:#d9534f;">Xóa eff đã chọn</button>
				</div>
				<div class="file-input-group" style="margin-top:0.5rem;">
					<label for="eff-selected-id">Cập nhật ID cho eff đã chọn</label>
					<input id="eff-selected-id" type="number" min="0" max="9999" step="1" value="0">
				</div>
				<button id="update-eff-id-button" class="action-button">Cập nhật ID eff đã chọn</button>
				<div class="file-input-group" style="margin-top:0.5rem;">
					<label for="eff-raw-input">Raw (nâng cao)</label>
					<input id="eff-raw-input" type="text" placeholder="0;ID;tileX;tileY;...">
				</div>
				<button id="update-eff-raw-button" class="action-button">Cập nhật Raw cho eff đã chọn</button>
				<div class="small-muted" style="margin-top: 0.5rem;">Mẹo: Giữ Ctrl để di chuyển bản đồ khi đang sửa eff.</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>8. Sửa Cổng VGO</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="vgo-edit-mode">
					<label for="vgo-edit-mode">Bật chế độ sửa cổng VGO (kéo thả / xóa)</label>
				</div>
				<div class="file-input-group">
					<label for="vgo-name-input">Tên cổng</label>
					<input id="vgo-name-input" type="text" placeholder="Tên cổng...">
				</div>
				<div class="inline" style="gap: 0.5rem; margin-top: 0.5rem;">
					<button id="add-vgo-button" class="action-button">Thêm cổng VGO</button>
					<button id="delete-vgo-button" class="action-button" style="background-color:#d9534f;">Xóa cổng VGO đã chọn</button>
				</div>
				<div class="small-muted" style="margin-top: 0.5rem;">Mẹo: Giữ Ctrl để di chuyển bản đồ khi đang sửa cổng VGO. Mũi tên chỉ hướng sẽ do client quyết định theo chuẩn của map.</div>
			</div>

			<div class="control-group" style="display:none;">
				<h2>9. NPC</h2>
				<div class="inline" style="margin-bottom: 0.5rem;">
					<input type="checkbox" id="npc-edit-mode">
					<label for="npc-edit-mode">Bật chế độ sửa NPC (kéo thả / xóa)</label>
				</div>
				<div class="file-input-group">
					<label for="npc-input">Tệp NPC (.dat)</label>
					<input type="file" id="npc-input" accept=".dat,.*" multiple>
				</div>
				<div class="inline" style="gap: 0.5rem;">
					<button id="add-npc-button" class="action-button">Thêm NPC</button>
					<button id="edit-npc-button" class="action-button" style="background-color:#6c757d;">Sửa NPC đã chọn</button>
					<button id="save-npcs-button" class="action-button" style="background-color:#0275d8;">Lưu NPC</button>
				</div>
				<div class="small-muted" style="margin-top: 0.5rem;">Icon minimap: dùng ảnh ID 3000 + iconMiniMap. Icon tương tác: 3500 + iconInteract.</div>
			</div>

			<div class="control-group" style="flex-grow: 1; display: none; flex-direction: column;">
				<h2>Nhật Ký (Log)</h2>
				<div id="log-entries-container" class="log-entries">
					<div id="initial-log-entry" class="log-entry"><span class="log-timestamp"></span>Chào mừng! Hãy tải file map để bắt đầu.</div>
				</div>
			</div>
		</div>
		
		<main id="canvas-container">
			<div id="welcome-message"><p>Vui lòng tải lên file bản đồ và ảnh tileset.</p></div>
			<canvas id="map-canvas" style="display: none;"></canvas>
			<!-- NPC Editor Modal -->
			<div id="npc-editor-modal">
				<h3 id="npc-editor-title">Edit NPC</h3>
				<form id="npc-editor-form">
					<div class="grid-2">
						<div class="field"><label>Tên</label><input name="name" type="text"></div>
						<div class="field"><label>Menu Title</label><input name="menuTitle" type="text"></div>
						<div class="field"><label>npcId</label><input name="npcId" type="number" step="1"></div>
						<div class="field"><label>iconMiniMap</label><input id="npc-iconMiniMap" name="iconMiniMap" type="number" step="1"></div>
						<div class="field"><label>X</label><input name="x" type="number" step="1"></div>
						<div class="field"><label>Y</label><input name="y" type="number" step="1"></div>
						<div class="field"><label>type1</label><input name="type1" type="number" step="1"></div>
						<div class="field"><label>type2</label><input name="type2" type="number" step="1"></div>
						<div class="field"><label>direction</label><input name="direction" type="number" step="1"></div>
						<div class="field"><label>iconInteract</label><input id="npc-iconInteract" name="iconInteract" type="number" step="1"></div>
						<div class="field"><label>flag1</label><input name="flag1" type="number" step="1"></div>
						<div class="field"><label>flag2</label><input name="flag2" type="number" step="1"></div>
					</div>
					<div class="field" style="margin-top:4px;">
						<label>dialog</label>
						<textarea name="dialog" rows="3"></textarea>
					</div>
					<div class="inline" style="justify-content: space-between; margin: 8px 0;">
						<div>
							<div class="small-muted">Minimap Preview</div>
							<div id="minimap-icon-preview" class="icon-preview">?</div>
						</div>
						<div>
							<div class="small-muted">Interact Preview</div>
							<div id="interact-icon-preview" class="icon-preview">?</div>
						</div>
					</div>
					<div id="npc-editor-actions">
						<button type="button" id="npc-editor-save" class="action-button">Lưu</button>
						<button type="button" id="npc-editor-cancel" class="action-button" style="background-color:#d9534f;">Hủy</button>
					</div>
				</form>
			</div>
		</main>
	</div>

	<script type="module">
class MapData {
	mapName = "";
	mapVersion = 0;
	width = 0;
	height = 0;
	tilesetId = -1;
	tileMap = [];
	vgos = [];
	effectObjects = [];
	effData = [];
	internalVgoCount = null;
	collisionMap = [];
	npcs = [];
}

const TILE_SIZE = 24;

class BinaryReader {
	view;
	offset;
	textDecoder;

	constructor(buffer) {
		this.view = new DataView(buffer);
		this.offset = 0;
		this.textDecoder = new TextDecoder('utf-8');
	}

	readByte() { return this.view.getInt8(this.offset++); }
	readShort() { const val = this.view.getInt16(this.offset, false); this.offset += 2; return val; }
	readUShort() { const val = this.view.getUint16(this.offset, false); this.offset += 2; return val; }
	readUTF() {
		const len = this.readUShort();
		const strBytes = new Uint8Array(this.view.buffer, this.offset, len);
		this.offset += len;
		return this.textDecoder.decode(strBytes);
	}
	readBytes(num) {
		const bytes = new Uint8Array(this.view.buffer, this.offset, num);
		this.offset += num;
		return bytes;
	}
	seek(offset, from = 'start') {
		if (from === 'start') this.offset = offset;
		else this.offset += offset;
	}
	get eof() { return this.offset >= this.view.byteLength; }
	getBuffer() { return this.view.buffer; }
	getInt8At(offset) { return this.view.getInt8(offset); }
	getUint8At(offset) { return this.view.getUint8(offset); }
}

class BinaryWriter {
	byteList = [];
	textEncoder;

	constructor() { this.textEncoder = new TextEncoder(); }

	writeByte(value) { this.byteList.push(value & 0xFF); }
	writeShort(value) {
		const arr = new Uint8Array(2);
		new DataView(arr.buffer).setInt16(0, value, false);
		this.byteList.push(...Array.from(arr));
	}
	writeUTF(str) {
		const encoded = this.textEncoder.encode(str);
		this.writeShort(encoded.length);
		this.byteList.push(...Array.from(encoded));
	}
	writeBytes(bytes) { this.byteList.push(...Array.from(bytes)); }
	getBuffer() { return new Uint8Array(this.byteList).buffer; }
}

class MapViewerApp {
	canvas;
	ctx;
	canvasContainer;
	welcomeMessage;
	logEntriesContainer;
	saveMapButton;
	textDecoder;
	
	mapData = null;
	tilesetImage = null;
	tilesetWaterImage = null;
	tilesetSmallImage = null;
	tilesetLibrary = { main: new Map(), water: new Map(), small: new Map() };
	effectIcons = new Map();
	npcFrameCache = new WeakMap();
	originalMapFileName = '';
	showOverlays = true;
	animationTickMs = 160;
	animationTimer = null;

	scale = 1.0;
	panX = 0;
	panY = 0;

	isPanning = false;
	lastMouseX = 0;
	lastMouseY = 0;

	// Collision state
	showCollision = true;
	collisionMode = 'number';
	fThreshold = 32;
	gThreshold = 26;

	// Tile edit state
	isTileEditingMode = false;
	isPainting = false;
	selectedTileId = 1;

	// Icon edit state
	isIconEditingMode = false;
	selectedEffectObject = null;
	isDraggingIcon = false;
	isCtrlDown = false;
	// Eff edit state
	isEffEditingMode = false;
	selectedEff = null;
	isDraggingEff = false;
	// VGO edit state
	isVgoEditingMode = false;
	selectedVgo = null;
	isDraggingVgo = false;
	// NPC edit state
	isNpcEditingMode = false;
	selectedNpc = null;
	isDraggingNpc = false;
	// NPC editor modal state
	npcEditorModal = null;
	npcEditorForm = null;
	npcEditorTitle = null;
	currentEditingNpc = null;
	isNewNpc = false;
	// Undo state
	undoStack = [];
	undoButton = null;
	topUndoButton = null;
	dragStartedForUndo = false;
	// Floating UI state
	floatingPanel = null;
	floatingContent = null;
	currentMode = 'none';

	constructor() {
		this.canvas = document.getElementById('map-canvas');
		this.ctx = this.canvas.getContext('2d');
		this.canvasContainer = document.getElementById('canvas-container');
		this.welcomeMessage = document.getElementById('welcome-message');
		this.logEntriesContainer = document.getElementById('log-entries-container');
		this.saveMapButton = document.getElementById('save-map-button');
		this.undoButton = document.getElementById('undo-button');
		this.textDecoder = new TextDecoder('utf-8');

		this.npcEditorModal = document.getElementById('npc-editor-modal');
		this.npcEditorForm = document.getElementById('npc-editor-form');
		this.npcEditorTitle = document.getElementById('npc-editor-title');

		this.initEventListeners();
		this.initTopToolbar();
		this.topUndoButton = document.getElementById('top-undo-btn');
		if (this.topUndoButton) { this.topUndoButton.addEventListener('click', this.handleUndo.bind(this)); this.topUndoButton.disabled = true; }
		this.log("Map viewer đã khởi tạo. Sẵn sàng nhận file.");
		this.startAnimationLoop();
	}

	log(message) {
		if (!this.logEntriesContainer) return;
		const initialLog = document.getElementById('initial-log-entry');
		if (initialLog) initialLog.remove();
		const timestamp = new Date().toLocaleTimeString('vi-VN');
		const newEntry = document.createElement('div');
		newEntry.className = 'log-entry';
		newEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message.replace(/\n/g, '<br>')}`;
		this.logEntriesContainer.prepend(newEntry);
		const fpLog = document.getElementById('fp-log-entries');
		if (fpLog) { fpLog.prepend(newEntry.cloneNode(true)); }
	}

	initEventListeners() {
		document.getElementById('map-input')?.addEventListener('change', this.handleMapFile.bind(this));
		document.getElementById('tileset-input')?.addEventListener('change', this.handleTilesetFile.bind(this));
		document.getElementById('icon-input')?.addEventListener('change', this.handleIconFiles.bind(this));
		this.saveMapButton.addEventListener('click', this.handleSaveMap.bind(this));

		document.getElementById('apply-resize-button')?.addEventListener('click', this.applyResizeFromUI.bind(this));
		
		// Collision controls
		const sc = document.getElementById('show-collision');
		const cm = document.getElementById('collision-mode');
		const ft = document.getElementById('f-threshold');
		const gt = document.getElementById('g-threshold');
		if (sc) sc.addEventListener('change', (e) => { this.showCollision = e.target.checked; this.render(); });
		if (cm) cm.addEventListener('change', (e) => { this.collisionMode = e.target.value; this.render(); });
		const onParam = () => { this.fThreshold = parseInt(ft.value||'32',10)||32; this.gThreshold = parseInt(gt.value||'26',10)||26; this.calculateCollisionMap(); this.render(); };
		if (ft) ft.addEventListener('input', onParam);
		if (gt) gt.addEventListener('input', onParam);
		
		// Tile/Icon/Eff/VGO/NPC controls are now handled via floating panel

		// NPC modal
		document.getElementById('npc-editor-save')?.addEventListener('click', this.handleNpcEditorSave.bind(this));
		document.getElementById('npc-editor-cancel')?.addEventListener('click', () => this.hideNpcEditor(true));
		document.getElementById('npc-iconMiniMap')?.addEventListener('input', () => { this.updateNpcEditorIconPreview('npc-iconMiniMap', 'minimap-icon-preview', 3000); });
		document.getElementById('npc-iconInteract')?.addEventListener('input', () => { this.updateNpcEditorIconPreview('npc-iconInteract', 'interact-icon-preview', 3500); });

		if (this.undoButton) this.undoButton.addEventListener('click', this.handleUndo.bind(this));
		
		this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
		this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
		this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
		this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
		this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
		this.canvas.addEventListener('drop', this.handleDrop.bind(this));
		this.canvas.addEventListener('dragover', this.handleDragOver.bind(this));
		this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
		const toggle = document.getElementById('toggle-overlays');
		if (toggle) toggle.addEventListener('change', (e) => { this.showOverlays = !!e.target.checked; this.render(); });
		window.addEventListener('resize', this.render.bind(this));
		// Ctrl tracking
		window.addEventListener('keydown', (e) => { if (e.key === 'Control') this.isCtrlDown = true; });
		window.addEventListener('keyup', (e) => { if (e.key === 'Control') this.isCtrlDown = false; });
	}

	initTopToolbar() {
		const toolbar = document.getElementById('top-toolbar');
		if (!toolbar) return;
		const buttons = Array.from(toolbar.querySelectorAll('.mode-button'));
		buttons.forEach(btn => {
			btn.addEventListener('click', () => {
				const mode = btn.getAttribute('data-mode');
				if (!mode) return;
				if (mode === 'log' || mode === 'file' || mode === 'resize' || mode === 'collision' || mode === 'tile' || mode === 'icon' || mode === 'eff' || mode === 'vgo' || mode === 'npc') {
					this.openMode(mode);
				}
			});
		});
	}

	updateModeButtonsState(active) {
		const toolbar = document.getElementById('top-toolbar');
		if (!toolbar) return;
		const buttons = Array.from(toolbar.querySelectorAll('.mode-button'));
		buttons.forEach(btn => {
			const mode = btn.getAttribute('data-mode');
			if (active && mode === active) btn.classList.add('active'); else btn.classList.remove('active');
		});
	}

	openMode(mode) {
		if (!mode) return;
		this.currentMode = mode;
		// Only toggle exclusive editing for canvas edit modes
		if (['tile','icon','eff','vgo','npc'].includes(mode)) {
			this.setExclusiveEditMode(mode);
		} else {
			this.setExclusiveEditMode('none');
		}
		this.ensureFloatingPanel();
		this.setFloatingContent(mode);
		this.updateModeButtonsState(mode);
	}

	ensureFloatingPanel() {
		if (this.floatingPanel) { this.floatingPanel.style.display = 'flex'; return; }
		const panel = document.createElement('div');
		panel.className = 'floating-panel';
		panel.id = 'floating-panel';
		panel.style.top = '80px';
		panel.style.left = '420px';
		const header = document.createElement('div');
		header.className = 'floating-header';
		const title = document.createElement('div');
		title.className = 'floating-title';
		title.id = 'floating-title';
		title.textContent = 'Editor';
		const controls = document.createElement('div'); controls.className = 'floating-controls';
		const minimizeBtn = document.createElement('button'); minimizeBtn.textContent = 'Thu nhỏ';
		const closeBtn = document.createElement('button'); closeBtn.textContent = 'Đóng';
		controls.appendChild(minimizeBtn); controls.appendChild(closeBtn);
		header.appendChild(title); header.appendChild(controls);
		const content = document.createElement('div'); content.className = 'floating-content';
		panel.appendChild(header); panel.appendChild(content);
		this.canvasContainer.appendChild(panel);
		this.floatingPanel = panel;
		this.floatingContent = content;
		this.enablePanelDrag(panel, header);
		minimizeBtn.addEventListener('click', () => this.minimizeFloatingPanel());
		closeBtn.addEventListener('click', () => { this.closeFloatingPanel(); this.updateModeButtonsState('none'); });
	}

	async handleMapFile(event) {
		const input = event.target;
		if (!input.files || input.files.length === 0) return;
		const file = input.files[0];
		this.originalMapFileName = file.name;
		this.log(`Bắt đầu tải file map: ${file.name}`);
		try {
			const buffer = await file.arrayBuffer();
			this.mapData = new MapData();
			const reader = new BinaryReader(buffer);
			this.log("Đang phân tích dữ liệu file map...");
			// Đọc 2 byte đầu để hỗ trợ chỉnh header
			try { const dv = new DataView(buffer); this.headerByte1 = dv.getUint8(0); this.headerByte2 = dv.getUint8(1); } catch {}
			reader.seek(2);
			this.mapData.mapName = reader.readUTF();
			this.mapData.mapVersion = reader.readShort();
			this.mapData.width = reader.readByte();
			this.mapData.height = reader.readByte();
			this.mapData.tilesetId = reader.readByte();
			this.log(`Thông tin map:\n- Tên: ${this.mapData.mapName}\n- Kích thước: ${this.mapData.width}x${this.mapData.height}\n- Tileset ID: ${this.mapData.tilesetId}\n- Header[0..1]=(${this.headerByte1}, ${this.headerByte2})\n- Version: 0x${this.mapData.mapVersion.toString(16).toUpperCase()}`);
			// Nếu đã có thư viện tileset, tự áp dụng theo ID map
			if (this.tilesetLibrary && this.tilesetLibrary.main && this.tilesetLibrary.main.size > 0) {
				this.applyTilesetById(this.mapData.tilesetId);
			}
			this.mapData.tileMap = [];
			const tileData = reader.readBytes(this.mapData.width * this.mapData.height);
			for (let y = 0; y < this.mapData.height; y++) {
				this.mapData.tileMap.push(Array.from(tileData.slice(y * this.mapData.width, (y + 1) * this.mapData.width)));
			}
			this.log(`Đã đọc ${this.mapData.tileMap.length * this.mapData.width} tiles.`);
			if (!reader.eof && reader.getInt8At(reader.offset) === -1) { reader.readByte(); }
			if (!reader.eof) {
				const objectBlockLength = reader.readShort();
				const objectBlockStartOffset = reader.offset;
				if (objectBlockStartOffset + objectBlockLength > reader.getBuffer().byteLength) {
					this.log("CẢNH BÁO: Object block length không hợp lệ, có thể file map bị lỗi.");
				} else {
					const objectBlockBuffer = reader.getBuffer().slice(objectBlockStartOffset, objectBlockStartOffset + objectBlockLength);
					const objectReader = new BinaryReader(objectBlockBuffer);
					const numIcons = objectReader.readShort();
					for (let i = 0; i < numIcons; i++) {
						if (objectReader.offset + 6 > objectBlockBuffer.byteLength) break;
						const templateId = objectReader.readShort();
						this.mapData.effectObjects.push({ templateId: templateId, x: objectReader.readShort() * TILE_SIZE, y: objectReader.readShort() * TILE_SIZE, text: "", name: `Effect ID: ${templateId}` });
					}
					this.log(`Đã đọc ${this.mapData.effectObjects.length} đối tượng trang trí (Icons).`);
					const tryParsePairs = () => {
						const save = objectReader.offset;
						try {
							if (objectReader.offset + 2 > objectBlockBuffer.byteLength) return false;
							const pairCount = objectReader.readShort();
							if (pairCount < 0 || pairCount > 10000) { objectReader.offset = save; return false; }
							let parsed = 0;
							for (let i = 0; i < pairCount; i++) {
								if (objectReader.offset + 2 > objectBlockBuffer.byteLength) throw new Error('overflow');
								let keyLen = objectReader.readByte(); keyLen = (keyLen + 256) % 256;
								if (objectReader.offset + keyLen > objectBlockBuffer.byteLength) throw new Error('overflow');
								const key = this.textDecoder.decode(objectReader.readBytes(keyLen));
								let valLen = objectReader.readByte(); valLen = (valLen + 256) % 256;
								if (objectReader.offset + valLen > objectBlockBuffer.byteLength) throw new Error('overflow');
								const val = this.textDecoder.decode(objectReader.readBytes(valLen));
								if (key === 'eff') {
									const effString = val;
									const parts = effString.split(';');
									if (parts.length >= 4) {
										const id = parseInt(parts[1], 10);
										const x = parseInt(parts[2], 10);
										const y = parseInt(parts[3], 10);
										if (!isNaN(id) && !isNaN(x) && !isNaN(y)) {
											this.mapData.effData.push({ id, x: x * TILE_SIZE, y: y * TILE_SIZE, name: `Eff ID: ${id}`, text: `Eff: ${id}`, raw: effString });
										}
									}
								} else if (key === 'vgo') {
									const parts = val.split(';');
									if (parts.length >= 4) {
										const tx = parseInt(parts[0], 10);
										const ty = parseInt(parts[1], 10);
										const name = parts[2] || '';
										const type = parseInt(parts[3], 10) || 0;
										if (!isNaN(tx) && !isNaN(ty)) { this.mapData.vgos.push({ x: tx * TILE_SIZE, y: ty * TILE_SIZE, name, mapGoId: type, xNew: 0, yNew: 0 }); }
									}
								}
								parsed++;
							}
							this.log(`Đã đọc ${parsed} cặp chuỗi (overlay pairs).`);
							return true;
						} catch (e) { objectReader.offset = save; return false; }
					};
					if (!tryParsePairs()) {
						if (objectReader.offset + 2 <= objectReader.getBuffer().byteLength) {
							this.mapData.internalVgoCount = objectReader.readShort();
							this.log(`Đã đọc trường internal VGO count, giá trị: ${this.mapData.internalVgoCount}.`);
						} else { this.mapData.internalVgoCount = 0; }
						const effMagicNumber = [0x03, 0x65, 0x66, 0x66];
						while (!objectReader.eof) {
							const currentOffset = objectReader.offset;
							if (currentOffset + 4 > objectReader.getBuffer().byteLength) break;
							const isEff = objectReader.getUint8At(currentOffset) === effMagicNumber[0] && objectReader.getUint8At(currentOffset + 1) === effMagicNumber[1] && objectReader.getUint8At(currentOffset + 2) === effMagicNumber[2] && objectReader.getUint8At(currentOffset + 3) === effMagicNumber[3];
							if (isEff) {
								objectReader.seek(4, 'current');
								try {
									const dataLength = objectReader.readByte();
									if (objectReader.offset + dataLength > objectReader.getBuffer().byteLength) break;
									const effStringBytes = objectReader.readBytes(dataLength);
									const effString = this.textDecoder.decode(effStringBytes);
									const parts = effString.split(';');
									if (parts.length >= 4) {
										const [id, x, y] = [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])];
										if (!isNaN(id) && !isNaN(x) && !isNaN(y)) { this.mapData.effData.push({ id, x: x * TILE_SIZE, y: y * TILE_SIZE, name: `Eff ID: ${id}`, text: `Eff: ${id}`, raw: effString }); }
									}
								} catch (e) { break; }
							} else if (objectReader.getBuffer().byteLength - currentOffset >= 5) {
								try {
									const vgoX = objectReader.readShort();
									const vgoY = objectReader.readShort();
									const vgoType = objectReader.readByte();
									let name = "";
									if (vgoType === 0) { const nameLen = objectReader.readByte(); name = this.textDecoder.decode(objectReader.readBytes(nameLen)); }
									else if (vgoType === 1) { name = objectReader.readUTF(); }
									else { break; }
									this.mapData.vgos.push({ x: vgoX * TILE_SIZE, y: vgoY * TILE_SIZE, name, mapGoId: vgoType + 1, xNew: 0, yNew: 0 });
								} catch (e) { break; }
							} else { break; }
						}
						this.log(`Đã đọc ${this.mapData.vgos.length} VGOs và ${this.mapData.effData.length} 'eff' blocks.`);
					}
					reader.seek(objectBlockStartOffset + objectBlockLength, 'start');
				}
			}
			if (!reader.eof) {
				try {
					const vgoCount = reader.readByte();
					if (vgoCount > 0 && vgoCount < 100) {
						for (let i = 0; i < vgoCount; i++) {
							const x = reader.readShort();
							const y = reader.readShort();
							const name = reader.readUTF();
							this.mapData.vgos.push({ x, y, name, mapGoId: 100, xNew: 0, yNew: 0 });
						}
						this.log(`Đã đọc ${vgoCount} VGOs bên ngoài.`);
					}
				} catch (e) { /* No external VGO block */ }
			}
			document.getElementById('new-width-input').value = String(this.mapData.width);
			document.getElementById('new-height-input').value = String(this.mapData.height);
			this.saveMapButton.disabled = false;
			const fpSaveBtn = document.getElementById('fp-save-map-button'); if (fpSaveBtn) fpSaveBtn.disabled = false;
			this.canvas.style.display = 'block';
			this.welcomeMessage.style.display = 'none';
			this.calculateCollisionMap();
			this.resetView();
			this.render();
			this.log(`Hoàn tất tải map '${this.mapData.mapName}'. Sẵn sàng để xem.`);
		} catch (error) {
			console.error("Lỗi khi phân tích file map:", error);
			this.log(`LỖI: Không thể phân tích file map. Chi tiết trong console.`);
		}
	}

	render() {
		requestAnimationFrame(() => {
			if (!this.mapData) return;
			this.canvas.width = this.canvasContainer.clientWidth;
			this.canvas.height = this.canvasContainer.clientHeight;
			this.ctx.save();
			this.ctx.imageSmoothingEnabled = false;
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.ctx.translate(this.panX, this.panY);
			this.ctx.scale(this.scale, this.scale);
			this.drawTileMap();
			this.drawCollisionLayer();
			this.drawObjects();
			this.ctx.restore();
		});
	}
	
	drawTileMap() {
		if (!this.mapData) return;
		if (!this.tilesetImage) {
			this.ctx.strokeStyle = '#555';
			this.ctx.lineWidth = 1 / this.scale;
			for (let y = 0; y < this.mapData.height; y++) { for (let x = 0; x < this.mapData.width; x++) { this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); } }
			return;
		}
		const tilesetCols = this.tilesetImage.width / TILE_SIZE;
		for (let y = 0; y < this.mapData.height; y++) {
			for (let x = 0; x < this.mapData.width; x++) {
				const tileId = (this.mapData.tileMap[y][x] | 0) - 1;
				if (tileId < 0) continue;
				const sx = (tileId % tilesetCols) * TILE_SIZE;
				const sy = Math.floor(tileId / tilesetCols) * TILE_SIZE;
				this.ctx.drawImage(this.tilesetImage, sx, sy, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
			}
		}
	}

	drawCollisionLayer() {
		if (!this.showCollision || !this.mapData || !this.mapData.collisionMap.length) return;
		const cm = this.mapData.collisionMap;
		for (let y = 0; y < cm.length; y++) {
			for (let x = 0; x < cm[y].length; x++) {
				const c = cm[y][x];
				const rectX = x * TILE_SIZE;
				const rectY = y * TILE_SIZE;
				if (this.collisionMode === 'color') {
					if (c === 1) { this.ctx.fillStyle = 'rgba(239, 68, 68, 0.4)'; this.ctx.fillRect(rectX, rectY, TILE_SIZE, TILE_SIZE); }
					else if (c === 2) { this.ctx.fillStyle = 'rgba(59, 130, 246, 0.4)'; this.ctx.fillRect(rectX, rectY, TILE_SIZE, TILE_SIZE); }
				} else {
					const centerX = rectX + TILE_SIZE / 2;
					const centerY = rectY + TILE_SIZE / 2;
					this.ctx.font = `bold ${12 / this.scale}px sans-serif`;
					this.ctx.textAlign = 'center';
					this.ctx.textBaseline = 'middle';
					this.ctx.lineWidth = 3 / this.scale;
					if (c === 1) { this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; this.ctx.fillStyle = '#fca5a5'; }
					else if (c === 2) { this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; this.ctx.fillStyle = '#93c5fd'; }
					else { this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)'; this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; }
					this.ctx.strokeText(String(c), centerX, centerY);
					this.ctx.fillText(String(c), centerX, centerY);
				}
			}
		}
	}

	drawObjects() {
		if (!this.mapData) return;
		const allObjects = [ ...this.mapData.effectObjects, ...this.mapData.vgos, ...this.mapData.effData, ...this.mapData.npcs ].sort((a,b) => a.y - b.y);
		allObjects.forEach(obj => {
			if (!this.showOverlays && (('templateId' in obj) || ('raw' in obj) || ('npcId' in obj))) return;
			if ('templateId' in obj) this.drawEffect(obj);
			else if ('mapGoId' in obj) this.drawVgo(obj);
			else if ('raw' in obj) this.drawEff(obj);
			else if ('npcId' in obj) this.drawNpc(obj);
		});
		if (this.isEffEditingMode && this.selectedEff && this.showOverlays) { this.highlightSelection(this.selectedEff.x, this.selectedEff.y, TILE_SIZE, TILE_SIZE); }
	}

	highlightSelection(x, y, w, h) {
		this.ctx.save();
		this.ctx.lineWidth = 2 / this.scale;
		this.ctx.strokeStyle = '#ffd700';
		this.ctx.setLineDash([6 / this.scale, 4 / this.scale]);
		this.ctx.strokeRect(x, y, w, h);
		this.ctx.restore();
	}

	drawVgo(vgo) {
		const centerX = vgo.x + TILE_SIZE / 2;
		const centerY = vgo.y + TILE_SIZE / 2;
		this.ctx.beginPath();
		this.ctx.arc(centerX, centerY, TILE_SIZE / 2, 0, 2 * Math.PI);
		this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
		this.ctx.fill();
		this.ctx.strokeStyle = (this.isVgoEditingMode && this.selectedVgo === vgo) ? '#ffd700' : '#2563EB';
		this.ctx.lineWidth = 1.5 / this.scale;
		this.ctx.stroke();
		if (this.isVgoEditingMode && this.mapData) { const dir = this.inferVgoDirection(vgo); const angle = this.directionAngle(dir); const alpha = 0.6 + 0.4 * Math.abs(Math.sin(Date.now() / 300)); this.ctx.save(); this.ctx.globalAlpha = alpha; this.drawArrow(centerX, centerY, angle); this.ctx.restore(); }
		if (vgo.name) { this.ctx.fillStyle = '#ffffff'; this.ctx.font = `bold ${11 / this.scale}px sans-serif`; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'bottom'; this.ctx.strokeStyle = 'black'; this.ctx.lineWidth = 2.5 / this.scale; const textY = vgo.y - (4 / this.scale); this.ctx.strokeText(vgo.name, centerX, textY); this.ctx.fillText(vgo.name, centerX, textY); }
	}
	
	drawEff(eff) {
		const isSelected = this.selectedEff === eff;
		this.ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
		this.ctx.strokeStyle = isSelected ? '#ffd700' : '#22c55e';
		this.ctx.lineWidth = 1 / this.scale;
		this.ctx.fillRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
		this.ctx.strokeRect(eff.x, eff.y, TILE_SIZE, TILE_SIZE);
		if (eff.text) { this.ctx.fillStyle = '#ffffff'; this.ctx.font = `bold ${14 / this.scale}px sans-serif`; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.strokeStyle = 'black'; this.ctx.lineWidth = 3 / this.scale; const textX = eff.x + TILE_SIZE / 2; const textY = eff.y + TILE_SIZE / 2; this.ctx.strokeText(eff.text, textX, textY); this.ctx.fillText(eff.text, textX, textY); }
	}
	
	drawEffect(effect) {
		const icon = this.effectIcons.get(effect.templateId);
		if (icon && icon.complete) {
			const drawX = effect.x + (TILE_SIZE - icon.width) / 2;
			const drawY = effect.y + (TILE_SIZE - icon.height) / 2;
			this.ctx.drawImage(icon, drawX, drawY, icon.width, icon.height);
		} else {
			this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
			this.ctx.strokeStyle = '#cccc00';
			this.ctx.lineWidth = 1 / this.scale;
			this.ctx.fillRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
			this.ctx.strokeRect(effect.x, effect.y, TILE_SIZE, TILE_SIZE);
		}
		if (this.isIconEditingMode && this.selectedEffectObject === effect) {
			const w = (icon && icon.complete) ? icon.width : TILE_SIZE;
			const h = (icon && icon.complete) ? icon.height : TILE_SIZE;
			const x = (icon && icon.complete) ? (effect.x + (TILE_SIZE - icon.width) / 2) : effect.x;
			const y = (icon && icon.complete) ? (effect.y + (TILE_SIZE - icon.height) / 2) : effect.y;
			this.highlightSelection(x, y, w, h);
		}
	}

	drawNpc(npc) {
		const finalIconId = 3000 + (npc.iconMiniMap | 0);
		const icon = this.effectIcons.get(finalIconId);
		if (icon && icon.complete) {
			const r = this.getIconFrameRect(icon);
			this.ctx.drawImage(icon, r.sx, r.sy, r.sw, r.sh, npc.x, npc.y, r.sw, r.sh);
			if (npc.name) {
				this.ctx.fillStyle = '#ffffff';
				this.ctx.font = `bold ${12 / this.scale}px sans-serif`;
				this.ctx.textAlign = 'center';
				this.ctx.strokeStyle = 'black';
				this.ctx.lineWidth = 2 / this.scale;
				const textX = npc.x + r.sw / 2;
				const textY = npc.y - 5 / this.scale;
				this.ctx.strokeText(npc.name, textX, textY);
				this.ctx.fillText(npc.name, textX, textY);
			}
			if (this.isNpcEditingMode && npc === this.selectedNpc) { this.ctx.strokeStyle = '#ffff00'; this.ctx.lineWidth = 2 / this.scale; this.ctx.strokeRect(npc.x, npc.y, r.sw, r.sh); }
		} else {
			this.ctx.fillStyle = 'rgba(148, 0, 211, 0.5)'; this.ctx.strokeStyle = '#9400D3'; this.ctx.lineWidth = 1 / this.scale; this.ctx.fillRect(npc.x, npc.y, TILE_SIZE, TILE_SIZE); this.ctx.strokeRect(npc.x, npc.y, TILE_SIZE, TILE_SIZE);
		}
	}

	// Utility methods
	screenToMapCoords(screenX, screenY) { return { x: (screenX - this.panX) / this.scale, y: (screenY - this.panY) / this.scale }; }

	resetView() {
		if (!this.mapData) return;
		this.scale = 1.0;
		const containerWidth = this.canvasContainer.clientWidth;
		const containerHeight = this.canvasContainer.clientHeight;
		const mapPixelWidth = this.mapData.width * TILE_SIZE;
		const mapPixelHeight = this.mapData.height * TILE_SIZE;
		this.scale = Math.min(containerWidth / mapPixelWidth, containerHeight / mapPixelHeight, 1.0) * 0.95;
		this.panX = (containerWidth - mapPixelWidth * this.scale) / 2;
		this.panY = (containerHeight - mapPixelHeight * this.scale) / 2;
		this.log(`View đã reset. Scale: ${this.scale.toFixed(2)}, Pan: (${this.panX.toFixed(0)}, ${this.panY.toFixed(0)})`);
	}

	calculateCollisionMap() {
		if (!this.mapData || !this.mapData.tileMap.length) { if (this.mapData) this.mapData.collisionMap = []; return; }
		const { width, height, tilesetId, tileMap } = this.mapData;
		const raw = Array(height).fill(null).map(() => Array(width).fill(0));
		for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				const id = tileMap[y][x] | 0;
				let c = 0;
				if (tilesetId < 9) { if (id >= this.fThreshold || id === 0) c = 1; else if (id >= this.gThreshold) c = 2; }
				else { if (id >= this.fThreshold || id === 0) c = 1; }
				raw[y][x] = c;
			}
		}
		const fin = raw.map(r => r.slice());
		const q = [];
		for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) if (raw[y][x] === 2) q.push({x,y});
		const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
		const lakeBedIds = new Set([32,33,34,35]);
		while (q.length) {
			const { x, y } = q.shift();
			for (const [dx, dy] of dirs) {
				const nx = x + dx, ny = y + dy;
				if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;
				if (fin[ny][nx] === 1 && lakeBedIds.has((tileMap[ny][nx] | 0))) { fin[ny][nx] = 2; q.push({ x: nx, y: ny }); }
			}
		}
		this.mapData.collisionMap = fin;
		this.log("Đã cập nhật bản đồ va chạm (0/1/2).");
	}

	// Mouse event handlers
	handleWheel(event) {
		if (!this.mapData) return;
		event.preventDefault();
		if (!this.isCtrlDown && (this.isTileEditingMode || this.isIconEditingMode || this.isEffEditingMode || this.isVgoEditingMode || this.isNpcEditingMode)) return;
		const rect = this.canvas.getBoundingClientRect();
		const mouseX = event.clientX - rect.left;
		const mouseY = event.clientY - rect.top;
		const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1;
		const newScale = Math.max(0.1, Math.min(this.scale * zoomFactor, 10.0));
		this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
		this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
		this.scale = newScale;
		this.render();
	}

	handleMouseDown(event) {
		if (!this.mapData) return;
		if (event.button !== 0) return;
		const rect = this.canvas.getBoundingClientRect();
		const sx = event.clientX - rect.left;
		const sy = event.clientY - rect.top;
		const { x: mx, y: my } = this.screenToMapCoords(sx, sy);
		if (this.isCtrlDown) { this.isPanning = true; }
		if (this.isTileEditingMode && !this.isCtrlDown) { this.isPainting = true; this.paintTileAt(mx, my); return; }
		this.isPanning = true;
		this.lastMouseX = event.clientX;
		this.lastMouseY = event.clientY;
		this.canvas.classList.add('grabbing');
	}

	handleMouseMove(event) {
		const rect = this.canvas.getBoundingClientRect();
		const sx = event.clientX - rect.left;
		const sy = event.clientY - rect.top;
		const { x: mx, y: my } = this.screenToMapCoords(sx, sy);
		if (this.isTileEditingMode && this.isPainting && !this.isCtrlDown) { this.paintTileAt(mx, my); return; }
		if (!this.isPanning) return;
		const dx = event.clientX - this.lastMouseX;
		const dy = event.clientY - this.lastMouseY;
		this.panX += dx;
		this.panY += dy;
		this.lastMouseX = event.clientX;
		this.lastMouseY = event.clientY;
		this.render();
	}
	
	handleMouseUp() {
		this.isPainting = false;
		this.isPanning = false;
		this.canvas.classList.remove('grabbing');
	}

	// Tile editing
	paintTileAt(mx, my) {
		if (!this.mapData) return;
		const tx = Math.floor(mx / TILE_SIZE);
		const ty = Math.floor(my / TILE_SIZE);
		if (tx < 0 || ty < 0 || tx >= this.mapData.width || ty >= this.mapData.height) return;
		if ((this.mapData.tileMap[ty][tx] | 0) === this.selectedTileId) return;
		this.mapData.tileMap[ty][tx] = this.selectedTileId | 0;
		this.calculateCollisionMap();
		this.render();
	}

	// Animation and initialization
	startAnimationLoop() {
		if (this.animationTimer) clearInterval(this.animationTimer);
		this.animationTimer = setInterval(() => { if (this.mapData) this.render(); }, this.animationTickMs);
	}

	// Tileset handling
	async handleTilesetFile(event) {
		const input = event.target;
		if (!input.files || input.files.length === 0) return;
		const file = input.files[0];
		this.log(`Đang tải file tileset: ${file.name}...`);
		this.tilesetImage = new Image();
		this.tilesetImage.onload = () => {
			this.log(`Tải thành công tileset '${file.name}'. Vẽ lại bản đồ.`);
			this.render();
		};
		this.tilesetImage.onerror = () => { this.log(`LỖI: Không thể tải ảnh tileset '${file.name}'.`); this.tilesetImage = null; }
		this.tilesetImage.src = URL.createObjectURL(file);
	}

	// Icon handling
	async handleIconFiles(event) {
		const input = event.target;
		if (!input.files) return;
		const files = Array.from(input.files);
		if (files.length === 0) { this.log("Không có file icon nào được chọn."); return; }
		this.log(`Bắt đầu tải ${files.length} file icon...`);
		let loadedCount = 0;
		let failedCount = 0;
		for (const f of files) {
			const name = f.name.replace(/\\/g,'/');
			const base = name.substring(name.lastIndexOf('/')+1);
			const baseNoExt = base.split('.')[0];
			const iconId = parseInt(baseNoExt);
			if (!isNaN(iconId)) {
				const img = new Image();
				img.src = URL.createObjectURL(f);
				try { await new Promise((res, rej) => { img.onload = res; img.onerror = rej; }); this.effectIcons.set(iconId, img); loadedCount++; }
				catch { failedCount++; }
			} else { failedCount++; }
		}
		this.log(`Hoàn tất tải icons. Thành công: ${loadedCount}, Thất bại: ${failedCount}. Vẽ lại bản đồ.`);
		this.render();
	}

	// NPC frame handling
	getIconFrameRect(img) {
		const w = img?.width || TILE_SIZE; const h = img?.height || TILE_SIZE;
		let cache = this.npcFrameCache.get(img);
		if (!cache || cache.w !== w || cache.h !== h || !Array.isArray(cache.slices)) {
			const slices = this.computeNpcVerticalSlices(img);
			cache = { w, h, frames: slices.length, slices, start: (Date.now() % (this.animationTickMs * 1000)) };
			this.npcFrameCache.set(img, cache);
		}
		const frames = cache.frames; const slices = cache.slices;
		const elapsed = Date.now() - (cache.start || 0);
		const idx = frames > 1 ? Math.floor(elapsed / this.animationTickMs) % frames : 0;
		const sl = slices[idx] || { sy: 0, sh: h };
		return { sx: 0, sy: sl.sy, sw: w, sh: sl.sh };
	}

	computeNpcVerticalSlices(img) {
		try {
			const w = img?.width || TILE_SIZE;
			const h = img?.height || TILE_SIZE;
			const ratio = h / Math.max(1, w);
			let frames = 1;
			if (ratio >= 1.45) frames = 2;
			if (ratio >= 3.1) frames = 4;
			const slices = [];
			if (frames === 1) { slices.push({ sy: 0, sh: h }); return slices; }
			const per = Math.floor(h / frames);
			const rem = h - per * frames;
			let y0 = 0;
			for (let i = 0; i < frames; i++) {
				const extra = i < rem ? 1 : 0;
				const sh = per + extra;
				slices.push({ sy: y0, sh: Math.max(1, sh) });
				y0 += sh;
			}
			return slices;
		} catch { return [{ sy: 0, sh: img?.height || TILE_SIZE }]; }
	}
}

// Initialize the application
new MapViewerApp();
	</script>
</body>
</html>
